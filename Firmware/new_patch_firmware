diff --git a/Images/navstik.prototype b/Images/navstik.prototype
new file mode 100644
index 0000000..d4b9f5a
--- /dev/null
+++ b/Images/navstik.prototype
@@ -0,0 +1,12 @@
+{
+    "board_id": 1, 
+    "magic": "Navstikv1", 
+    "description": "Firmware for the Navstik board", 
+    "image": "", 
+    "build_time": 0, 
+    "summary": "Navstik",
+    "version": "0.1",
+    "image_size": 0,
+    "git_identity": "",
+    "board_revision": 0
+}
diff --git a/Makefile b/Makefile
index 7f98ffa..8ffed9b 100644
--- a/Makefile
+++ b/Makefile
@@ -30,24 +30,24 @@
 #
 
 #
-# Top-level Makefile for building PX4 firmware images.
+# Top-level Makefile for building NAVSTIK firmware images.
 #
 
 #
 # Get path and tool configuration
 #
-export PX4_BASE		 := $(realpath $(dir $(lastword $(MAKEFILE_LIST))))/
-include $(PX4_BASE)makefiles/setup.mk
+export NAVSTIK_BASE		 := $(realpath $(dir $(lastword $(MAKEFILE_LIST))))/
+include $(NAVSTIK_BASE)makefiles/setup.mk
 
 #
 # Canned firmware configurations that we build.
 #
-CONFIGS			?= $(subst config_,,$(basename $(notdir $(wildcard $(PX4_MK_DIR)config_*.mk))))
+CONFIGS			?= $(subst config_,,$(basename $(notdir $(wildcard $(NAVSTIK_MK_DIR)config_*.mk))))
 
 #
 # Boards that we build NuttX export kits for.
 #
-BOARDS			:= $(subst board_,,$(basename $(notdir $(wildcard $(PX4_MK_DIR)board_*.mk))))
+BOARDS			:= $(subst board_,,$(basename $(notdir $(wildcard $(NAVSTIK_MK_DIR)board_*.mk))))
 
 #
 # Debugging
@@ -87,36 +87,36 @@ endif
 #
 # Built products
 #
-STAGED_FIRMWARES	 = $(foreach config,$(CONFIGS),$(IMAGE_DIR)$(config).px4)
-FIRMWARES		 = $(foreach config,$(CONFIGS),$(BUILD_DIR)$(config).build/firmware.px4)
+STAGED_FIRMWARES	 = $(foreach config,$(CONFIGS),$(IMAGE_DIR)$(config).navstik)
+FIRMWARES		 = $(foreach config,$(CONFIGS),$(BUILD_DIR)$(config).build/firmware.navstik)
 
 all:			$(STAGED_FIRMWARES)
 
 #
 # Copy FIRMWARES into the image directory.
 #
-# XXX copying the .bin files is a hack to work around the PX4IO uploader 
-#     not supporting .px4 files, and it should be deprecated onced that 
+# XXX copying the .bin files is a hack to work around the NAVSTIK uploader 
+#     not supporting .navstik files, and it should be deprecated onced that 
 #     is taken care of.
 #
-$(STAGED_FIRMWARES): $(IMAGE_DIR)%.px4: $(BUILD_DIR)%.build/firmware.px4
+$(STAGED_FIRMWARES): $(IMAGE_DIR)%.navstik: $(BUILD_DIR)%.build/firmware.navstik
 	@echo %% Copying $@
 	$(Q) $(COPY) $< $@
-	$(Q) $(COPY) $(patsubst %.px4,%.bin,$<) $(patsubst %.px4,%.bin,$@)
+	$(Q) $(COPY) $(patsubst %.navstik,%.bin,$<) $(patsubst %.navstik,%.bin,$@)
 
 #
 # Generate FIRMWARES.
 #
 .PHONY: $(FIRMWARES)
-$(BUILD_DIR)%.build/firmware.px4: config   = $(patsubst $(BUILD_DIR)%.build/firmware.px4,%,$@)
-$(BUILD_DIR)%.build/firmware.px4: work_dir = $(BUILD_DIR)$(config).build/
-$(FIRMWARES): $(BUILD_DIR)%.build/firmware.px4:
+$(BUILD_DIR)%.build/firmware.navstik: config   = $(patsubst $(BUILD_DIR)%.build/firmware.navstik,%,$@)
+$(BUILD_DIR)%.build/firmware.navstik: work_dir = $(BUILD_DIR)$(config).build/
+$(FIRMWARES): $(BUILD_DIR)%.build/firmware.navstik:
 	@echo %%%%
 	@echo %%%% Building $(config) in $(work_dir)
 	@echo %%%%
 	$(Q) mkdir -p $(work_dir)
 	$(Q) make -r -C $(work_dir) \
-		-f $(PX4_MK_DIR)firmware.mk \
+		-f $(NAVSTIK_MK_DIR)firmware.mk \
 		CONFIG=$(config) \
 		WORK_DIR=$(work_dir) \
 		$(FIRMWARE_GOAL)
@@ -132,8 +132,6 @@ $(FIRMWARES): $(BUILD_DIR)%.build/firmware.px4:
 # XXX Should support fetching/unpacking from a separate directory to permit
 #     downloads of the prebuilt archives as well...
 #
-# XXX PX4IO configuration name is bad - NuttX configs should probably all be "px4"
-#
 NUTTX_ARCHIVES		 = $(foreach board,$(BOARDS),$(ARCHIVE_DIR)$(board).export)
 .PHONY:			archives
 archives:		$(NUTTX_ARCHIVES)
@@ -164,10 +162,9 @@ $(NUTTX_ARCHIVES): $(ARCHIVE_DIR)%.export: $(NUTTX_SRC) $(NUTTX_APPS)
 .PHONY:	clean
 clean:
 	$(Q) $(RMDIR) $(BUILD_DIR)*.build
-	$(Q) $(REMOVE) $(IMAGE_DIR)*.px4
+	$(Q) $(REMOVE) $(IMAGE_DIR)*.navstik
 
 .PHONY:	distclean
-distclean: clean
 	$(Q) $(REMOVE) $(ARCHIVE_DIR)*.export
 	$(Q) make -C $(NUTTX_SRC) -r $(MQUIET) distclean
 
@@ -177,7 +174,7 @@ distclean: clean
 .PHONY: help
 help:
 	@echo ""
-	@echo " PX4 firmware builder"
+	@echo " NAVSTIK firmware builder"
 	@echo " ===================="
 	@echo ""
 	@echo "  Available targets:"
diff --git a/ROMFS/navstik/init.d/rc.navstik b/ROMFS/navstik/init.d/rc.navstik
new file mode 100644
index 0000000..2db8aab
--- /dev/null
+++ b/ROMFS/navstik/init.d/rc.navstik
@@ -0,0 +1,64 @@
+#!nsh
+ 
+# Disable USB and autostart
+set USB no
+ 
+echo "[init] doing Navstik Pandapilot startup..."
+ 
+#
+# Start the ORB (first app to start)
+#
+uorb start
+ 
+#
+# Load microSD params
+#
+echo "[init] loading microSD params"
+param select /fs/microsd/params
+if [ -f /fs/microsd/params ]
+then
+	param load /fs/microsd/params
+fi
+ 
+#
+# Force some key parameters to sane values
+# MAV_TYPE     1 = fixed wing, 2 = quadrotor, 13 = hexarotor
+#              see https://pixhawk.ethz.ch/mavlink/
+#
+param set MAV_TYPE 2
+ 
+#
+# Start MAVLink (depends on orb)
+#
+mavlink start -d /dev/ttyS1 -b 57600
+usleep 5000
+ 
+#
+# Start the commander (depends on orb, mavlink)
+#
+commander start
+ 
+#
+# Start the sensors (depends on orb, px4io)
+#
+sh /etc/init.d/rc.sensors
+ 
+#
+# Start GPS interface (depends on orb)
+#
+gps start
+ 
+ 
+#
+# Load mixer and start controllers
+#
+#mixer load /dev/pwm_output /etc/mixers/FMU_Q.mix
+#control_demo start
+ 
+#
+# Start logging
+#
+sdlog start -s 4
+ 
+echo "[init] startup done, exiting"
+exit
diff --git a/ROMFS/navstik/init.d/rc.sensors b/ROMFS/navstik/init.d/rc.sensors
new file mode 100644
index 0000000..6d93b58
--- /dev/null
+++ b/ROMFS/navstik/init.d/rc.sensors
@@ -0,0 +1,41 @@
+#!nsh
+#
+# Standard startup script for Navstik onboard sensor drivers.
+#
+
+#
+# Check for UORB
+#
+if uorb start
+then
+	echo "uORB started"
+fi
+
+#
+# Start sensor drivers here.
+#
+ms5611 start
+adc start
+
+if mpu6000 start
+then
+	echo "using MPU6000 and HMC5883L"
+	hmc5883 start
+else
+	echo "using L3GD20 and LSM303D"
+	l3gd20 start
+	lsm303 start
+fi
+
+#
+# Start the sensor collection task.
+# IMPORTANT: this also loads param offsets
+# ALWAYS start this task before the
+# preflight_check.
+#
+sensors start
+
+#
+# Check sensors - run AFTER 'sensors start'
+#
+preflight_check
diff --git a/ROMFS/navstik/init.d/rcS b/ROMFS/navstik/init.d/rcS
new file mode 100644
index 0000000..4173e66
--- /dev/null
+++ b/ROMFS/navstik/init.d/rcS
@@ -0,0 +1,78 @@
+#!nsh
+#
+# Pandapilot startup script.
+#
+# This script is responsible for:
+#
+# - mounting the microSD card (if present)
+# - running the user startup script from the microSD card (if present)
+# - detecting the configuration of the system and picking a suitable
+#   startup script to continue with
+#
+# Note: DO NOT add configuration-specific commands to this script;
+#       add them to the per-configuration scripts instead.
+#
+
+#
+# Default to auto-start mode.  An init script on the microSD card
+# can change this to prevent automatic startup of the flight script.
+#
+set MODE autostart
+set USB autoconnect
+
+#
+# Try to mount the microSD card.
+#
+echo "[init] looking for microSD..."
+if mount -t vfat /dev/mmcsd0 /fs/microsd
+then
+	echo "[init] card mounted at /fs/microsd"
+	# Start playing the startup tune
+	tone_alarm start
+else
+	echo "[init] no microSD card found"
+	# Play SOS
+	tone_alarm 2
+fi
+
+#
+# Look for an init script on the microSD card.
+#
+# To prevent automatic startup in the current flight mode,
+# the script should set MODE to some other value.
+#
+if [ -f /fs/microsd/etc/rc ]
+then
+	echo "[init] reading /fs/microsd/etc/rc"
+	sh /fs/microsd/etc/rc
+fi
+# Also consider rc.txt files
+if [ -f /fs/microsd/etc/rc.txt ]
+then
+	echo "[init] reading /fs/microsd/etc/rc.txt"
+	sh /fs/microsd/etc/rc.txt
+fi
+
+#
+# Check for USB host
+#
+if [ $USB != autoconnect ]
+then
+	echo "[init] not connecting USB"
+else
+	if sercon
+	then
+		echo "[init] USB interface connected"
+	else
+		echo "[init] No USB connected"
+	fi
+fi
+
+# if this is an APM build then there will be a rc.APM script
+# from an EXTERNAL_SCRIPTS build option
+if [ -f /etc/init.d/rc.APM ]
+then
+	echo Running rc.APM
+	# if APM startup is successful then nsh will exit
+	sh /etc/init.d/rc.APM
+fi
diff --git a/Tools/navstik_mkfw.py b/Tools/navstik_mkfw.py
new file mode 100755
index 0000000..9f4ddad
--- /dev/null
+++ b/Tools/navstik_mkfw.py
@@ -0,0 +1,110 @@
+#!/usr/bin/env python
+############################################################################
+#
+#   Copyright (C) 2012 PX4 Development Team. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name PX4 nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+#
+# PX4 firmware image generator
+#
+# The PX4 firmware file is a JSON-encoded Python object, containing
+# metadata fields and a zlib-compressed base64-encoded firmware image.
+#
+
+import sys
+import argparse
+import json
+import base64
+import zlib
+import time
+import subprocess
+
+#
+# Construct a basic firmware description
+#
+def mkdesc():
+	proto = {}
+	proto['magic']		= "PX4FWv1"
+	proto['board_id']	= 0
+	proto['board_revision']	= 0
+	proto['version']	= ""
+	proto['summary']	= ""
+	proto['description']	= ""
+	proto['git_identity']	= ""
+	proto['build_time']	= 0
+	proto['image']		= base64.b64encode(bytearray())
+	proto['image_size']	= 0
+	return proto
+
+# Parse commandline
+parser = argparse.ArgumentParser(description="Firmware generator for the PX autopilot system.")
+parser.add_argument("--prototype",	action="store", help="read a prototype description from a file")
+parser.add_argument("--board_id",	action="store", help="set the board ID required")
+parser.add_argument("--board_revision",	action="store", help="set the board revision required")
+parser.add_argument("--version",	action="store", help="set a version string")
+parser.add_argument("--summary",	action="store", help="set a brief description")
+parser.add_argument("--description",	action="store", help="set a longer description")
+parser.add_argument("--git_identity",	action="store", help="the working directory to check for git identity")
+parser.add_argument("--image",		action="store", help="the firmware image")
+args = parser.parse_args()
+
+# Fetch the firmware descriptor prototype if specified
+if args.prototype != None:
+	f = open(args.prototype,"r")
+	desc = json.load(f)
+	f.close()
+else:
+	desc = mkdesc()
+
+desc['build_time'] 		= int(time.time())
+
+if args.board_id != None:
+	desc['board_id']	= int(args.board_id)
+if args.board_revision != None:
+	desc['board_revision']	= int(args.board_revision)
+if args.version != None:
+	desc['version']		= str(args.version)
+if args.summary != None:
+	desc['summary']		= str(args.summary)
+if args.description != None:
+	desc['description']	= str(args.description)
+if args.git_identity != None:
+	cmd = " ".join(["git", "--git-dir", args.git_identity + "/.git", "describe", "--always", "--dirty"])
+	p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE).stdout
+	desc['git_identity']	= p.read().strip()
+	p.close()
+if args.image != None:
+	f = open(args.image, "rb")
+	bytes = f.read()
+	desc['image_size'] = len(bytes)
+	desc['image'] = base64.b64encode(zlib.compress(bytes,9))
+
+print json.dumps(desc, indent=4)
diff --git a/makefiles/board_navstik.mk b/makefiles/board_navstik.mk
new file mode 100644
index 0000000..b261881
--- /dev/null
+++ b/makefiles/board_navstik.mk
@@ -0,0 +1,10 @@
+#
+# Board-specific definitions for the Navstik
+#
+
+#
+# Configure the toolchain
+#
+CONFIG_ARCH			 = CORTEXM4F
+
+include $(NAVSTIK_MK_DIR)/toolchain_gnu-arm-eabi.mk
diff --git a/makefiles/board_px4fmu-v1.mk b/makefiles/board_px4fmu-v1.mk
deleted file mode 100644
index 8370696..0000000
--- a/makefiles/board_px4fmu-v1.mk
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# Board-specific definitions for the PX4FMU
-#
-
-#
-# Configure the toolchain
-#
-CONFIG_ARCH			 = CORTEXM4F
-
-include $(PX4_MK_DIR)/toolchain_gnu-arm-eabi.mk
diff --git a/makefiles/board_px4io-v1.mk b/makefiles/board_px4io-v1.mk
deleted file mode 100644
index b0eb2da..0000000
--- a/makefiles/board_px4io-v1.mk
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# Board-specific definitions for the PX4IO
-#
-
-#
-# Configure the toolchain
-#
-CONFIG_ARCH			 = CORTEXM3
-
-include $(PX4_MK_DIR)/toolchain_gnu-arm-eabi.mk
diff --git a/makefiles/config_navstik_default.mk b/makefiles/config_navstik_default.mk
new file mode 100644
index 0000000..fd05ff3
--- /dev/null
+++ b/makefiles/config_navstik_default.mk
@@ -0,0 +1,127 @@
+#
+# Makefile for the navstik_default configuration
+#
+
+#
+# Use the configuration's ROMFS.
+#
+ROMFS_ROOT	 = $(NAVSTIK_BASE)/ROMFS/navstik
+
+#
+# Board support modules
+#
+MODULES		+= drivers/device
+MODULES		+= drivers/stm32
+MODULES		+= drivers/stm32/adc
+MODULES		+= drivers/led
+MODULES		+= drivers/boards/navstik
+MODULES		+= drivers/navstik
+#MODULES		+= drivers/ardrone_interface
+MODULES		+= drivers/bmp180
+MODULES		+= drivers/mpu60x0
+MODULES		+= drivers/hmc5883
+MODULES		+= drivers/gps
+#MODULES		+= drivers/hil
+#MODULES		+= drivers/hott/hott_telemetry
+#MODULES		+= drivers/mkblctrl
+#MODULES		+= drivers/md25
+MODULES		+= modules/sensors
+
+#
+# System commands
+#
+#MODULES		+= systemcmds/eeprom
+MODULES		+= systemcmds/bl_update
+MODULES		+= systemcmds/boardinfo
+MODULES		+= systemcmds/i2c
+MODULES		+= systemcmds/mixer
+MODULES		+= systemcmds/param
+MODULES		+= systemcmds/perf
+MODULES		+= systemcmds/preflight_check
+MODULES		+= systemcmds/pwm
+MODULES		+= systemcmds/reboot
+MODULES		+= systemcmds/top
+MODULES		+= systemcmds/tests
+
+#
+# General system control
+#
+MODULES		+= modules/commander
+MODULES		+= modules/mavlink
+MODULES		+= modules/mavlink_onboard
+#MODULES		+= modules/gpio_led
+
+#
+# Estimation modules (EKF / other filters)
+#
+MODULES		+= modules/attitude_estimator_ekf
+MODULES		+= modules/attitude_estimator_so3_comp
+#MODULES		+= modules/position_estimator_mc
+MODULES		+= modules/position_estimator
+MODULES		+= modules/att_pos_estimator_ekf
+
+#
+# Vehicle Control
+#
+MODULES		+= modules/fixedwing_backside
+MODULES		+= modules/fixedwing_att_control
+MODULES		+= modules/fixedwing_pos_control
+MODULES		+= modules/multirotor_att_control
+MODULES		+= modules/multirotor_pos_control
+
+#
+# Logging
+#
+MODULES		+= modules/sdlog2
+
+#
+# Library modules
+#
+MODULES		+= modules/systemlib
+MODULES		+= modules/systemlib/mixer
+MODULES		+= modules/mathlib
+MODULES		+= modules/controllib
+MODULES		+= modules/uORB
+
+#
+# Libraries
+#
+LIBRARIES	+= modules/mathlib/CMSIS
+
+#
+# Demo apps
+#
+#MODULES		+= examples/math_demo
+# Tutorial code from
+# https://pixhawk.ethz.ch/px4/dev/hello_sky
+#MODULES		+= examples/px4_simple_app
+
+# Tutorial code from
+# https://pixhawk.ethz.ch/px4/dev/daemon
+#MODULES		+= examples/px4_daemon_app
+
+# Tutorial code from
+# https://pixhawk.ethz.ch/px4/dev/debug_values
+#MODULES		+= examples/px4_mavlink_debug
+
+# Tutorial code from
+# https://pixhawk.ethz.ch/px4/dev/example_fixedwing_control
+MODULES			+= examples/fixedwing_control
+
+#
+# Transitional support - add commands from the NuttX export archive.
+#
+# In general, these should move to modules over time.
+#
+# Each entry here is <command>.<priority>.<stacksize>.<entrypoint> but we use a helper macro
+# to make the table a bit more readable.
+#
+define _B
+	$(strip $1).$(or $(strip $2),SCHED_PRIORITY_DEFAULT).$(or $(strip $3),CONFIG_PTHREAD_STACK_DEFAULT).$(strip $4)
+endef
+
+#                  command                 priority                   stack  entrypoint
+BUILTIN_COMMANDS := \
+	$(call _B, sercon,                 ,                          2048,  sercon_main                ) \
+	$(call _B, serdis,                 ,                          2048,  serdis_main                ) \
+	$(call _B, sysinfo,                ,                          2048,  sysinfo_main               )
diff --git a/makefiles/config_px4fmu-v1_default.mk b/makefiles/config_px4fmu-v1_default.mk
deleted file mode 100644
index 74be1cd..0000000
--- a/makefiles/config_px4fmu-v1_default.mk
+++ /dev/null
@@ -1,137 +0,0 @@
-#
-# Makefile for the px4fmu_default configuration
-#
-
-#
-# Use the configuration's ROMFS.
-#
-ROMFS_ROOT	 = $(PX4_BASE)/ROMFS/px4fmu_common
-
-#
-# Board support modules
-#
-MODULES		+= drivers/device
-MODULES		+= drivers/stm32
-MODULES		+= drivers/stm32/adc
-MODULES		+= drivers/stm32/tone_alarm
-MODULES		+= drivers/led
-MODULES		+= drivers/px4io
-MODULES		+= drivers/px4fmu
-MODULES		+= drivers/boards/px4fmu
-MODULES		+= drivers/ardrone_interface
-MODULES		+= drivers/l3gd20
-MODULES		+= drivers/bma180
-MODULES		+= drivers/mpu6000
-MODULES		+= drivers/hmc5883
-MODULES		+= drivers/ms5611
-MODULES		+= drivers/mb12xx
-MODULES		+= drivers/gps
-MODULES		+= drivers/hil
-MODULES		+= drivers/hott/hott_telemetry
-MODULES		+= drivers/hott/hott_sensors
-MODULES		+= drivers/blinkm
-MODULES		+= drivers/mkblctrl
-MODULES		+= drivers/md25
-MODULES		+= drivers/ets_airspeed
-MODULES		+= modules/sensors
-
-#
-# System commands
-#
-MODULES		+= systemcmds/eeprom
-MODULES		+= systemcmds/bl_update
-MODULES		+= systemcmds/boardinfo
-MODULES		+= systemcmds/i2c
-MODULES		+= systemcmds/mixer
-MODULES		+= systemcmds/param
-MODULES		+= systemcmds/perf
-MODULES		+= systemcmds/preflight_check
-MODULES		+= systemcmds/pwm
-MODULES		+= systemcmds/reboot
-MODULES		+= systemcmds/top
-MODULES		+= systemcmds/tests
-
-#
-# General system control
-#
-MODULES		+= modules/commander
-MODULES		+= modules/mavlink
-MODULES		+= modules/mavlink_onboard
-MODULES		+= modules/gpio_led
-
-#
-# Estimation modules (EKF / other filters)
-#
-MODULES		+= modules/attitude_estimator_ekf
-MODULES		+= modules/attitude_estimator_so3_comp
-MODULES		+= modules/position_estimator
-MODULES		+= modules/att_pos_estimator_ekf
-MODULES		+= examples/flow_position_estimator
-
-#
-# Vehicle Control
-#
-MODULES		+= modules/fixedwing_backside
-MODULES		+= modules/fixedwing_att_control
-MODULES		+= modules/fixedwing_pos_control
-MODULES		+= modules/multirotor_att_control
-MODULES		+= modules/multirotor_pos_control
-MODULES		+= examples/flow_position_control
-MODULES		+= examples/flow_speed_control
-
-#
-# Logging
-#
-MODULES		+= modules/sdlog2
-
-#
-# Library modules
-#
-MODULES		+= modules/systemlib
-MODULES		+= modules/systemlib/mixer
-MODULES		+= modules/mathlib
-MODULES		+= modules/controllib
-MODULES		+= modules/uORB
-
-#
-# Libraries
-#
-LIBRARIES	+= modules/mathlib/CMSIS
-
-#
-# Demo apps
-#
-#MODULES		+= examples/math_demo
-# Tutorial code from
-# https://pixhawk.ethz.ch/px4/dev/hello_sky
-#MODULES		+= examples/px4_simple_app
-
-# Tutorial code from
-# https://pixhawk.ethz.ch/px4/dev/daemon
-#MODULES		+= examples/px4_daemon_app
-
-# Tutorial code from
-# https://pixhawk.ethz.ch/px4/dev/debug_values
-#MODULES		+= examples/px4_mavlink_debug
-
-# Tutorial code from
-# https://pixhawk.ethz.ch/px4/dev/example_fixedwing_control
-MODULES			+= examples/fixedwing_control
-
-#
-# Transitional support - add commands from the NuttX export archive.
-#
-# In general, these should move to modules over time.
-#
-# Each entry here is <command>.<priority>.<stacksize>.<entrypoint> but we use a helper macro
-# to make the table a bit more readable.
-#
-define _B
-	$(strip $1).$(or $(strip $2),SCHED_PRIORITY_DEFAULT).$(or $(strip $3),CONFIG_PTHREAD_STACK_DEFAULT).$(strip $4)
-endef
-
-#                  command                 priority                   stack  entrypoint
-BUILTIN_COMMANDS := \
-	$(call _B, sercon,                 ,                          2048,  sercon_main                ) \
-	$(call _B, serdis,                 ,                          2048,  serdis_main                ) \
-	$(call _B, sysinfo,                ,                          2048,  sysinfo_main               )
diff --git a/makefiles/config_px4io-v1_default.mk b/makefiles/config_px4io-v1_default.mk
deleted file mode 100644
index cf70391..0000000
--- a/makefiles/config_px4io-v1_default.mk
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# Makefile for the px4io_default configuration
-#
-
-#
-# Board support modules
-#
-MODULES		+= drivers/stm32
-MODULES		+= drivers/boards/px4io
-MODULES		+= modules/px4iofirmware
\ No newline at end of file
diff --git a/makefiles/firmware.mk b/makefiles/firmware.mk
index f1c1b49..edc3844 100644
--- a/makefiles/firmware.mk
+++ b/makefiles/firmware.mk
@@ -30,12 +30,12 @@
 #
 
 #
-# Generic Makefile for PX4 firmware images.
+# Generic Makefile for NAVSTIK firmware images.
 #
 # Requires:
 #
 # BOARD
-#	Must be set to a board name known to the PX4 distribution (as
+#	Must be set to a board name known to the NAVSTIK distribution (as
 #	we need a corresponding NuttX export archive to link with).
 #
 # Optional:
@@ -48,7 +48,7 @@
 #		$(MODULE_SEARCH_DIRS)
 #		WORK_DIR
 #		MODULE_SRC
-#		PX4_MODULE_SRC
+#		NAVSTIK_MODULE_SRC
 #
 #	Application directories are expected to contain a module.mk
 #	file which provides build configuration for the module. See
@@ -59,8 +59,8 @@
 #	by modules / libraries. Each entry in this list is formatted
 #	as <command>.<priority>.<stacksize>.<entrypoint>
 #
-# PX4_BASE:
-#	Points to a PX4 distribution. Normally determined based on the
+# NAVSTIK_BASE:
+#	Points to a NAVSTIK distribution. Normally determined based on the
 #	path to this file.
 #
 # CONFIG:
@@ -98,16 +98,16 @@
 # Work out where this file is, so we can find other makefiles in the
 # same directory.
 #
-# If PX4_BASE wasn't set previously, work out what it should be
+# If NAVSTIK_BASE wasn't set previously, work out what it should be
 # and set it here now.
 #
 MK_DIR			?= $(dir $(lastword $(MAKEFILE_LIST)))
-ifeq ($(PX4_BASE),)
-export PX4_BASE		:= $(abspath $(MK_DIR)/..)
+ifeq ($(NAVSTIK_BASE),)
+export NAVSTIK_BASE		:= $(abspath $(MK_DIR)/..)
 endif
-$(info %  PX4_BASE            = $(PX4_BASE))
-ifneq ($(words $(PX4_BASE)),1)
-$(error Cannot build when the PX4_BASE path contains one or more space characters.)
+$(info %  NAVSTIK_BASE            = $(NAVSTIK_BASE))
+ifneq ($(words $(NAVSTIK_BASE)),1)
+$(error Cannot build when the NAVSTIK_BASE path contains one or more space characters.)
 endif
 
 #
@@ -130,7 +130,7 @@ include $(MK_DIR)/setup.mk
 ifneq ($(CONFIG_FILE),)
 CONFIG			:= $(subst config_,,$(basename $(notdir $(CONFIG_FILE))))
 else
-CONFIG_FILE		:= $(wildcard $(PX4_MK_DIR)/config_$(CONFIG).mk)
+CONFIG_FILE		:= $(wildcard $(NAVSTIK_MK_DIR)/config_$(CONFIG).mk)
 endif
 ifeq ($(CONFIG),)
 $(error Missing configuration name or file (specify with CONFIG=<config>))
@@ -148,7 +148,7 @@ $(info %  CONFIG              = $(CONFIG))
 ifeq ($(BOARD),)
 BOARD			:= $(firstword $(subst _, ,$(CONFIG)))
 endif
-BOARD_FILE		:= $(wildcard $(PX4_MK_DIR)/board_$(BOARD).mk)
+BOARD_FILE		:= $(wildcard $(NAVSTIK_MK_DIR)/board_$(BOARD).mk)
 ifeq ($(BOARD_FILE),)
 $(error Config $(CONFIG) references board $(BOARD), but no board definition file found)
 endif
@@ -180,14 +180,14 @@ EXTRA_CLEANS		 =
 # NuttX libraries and paths
 ################################################################################
 
-include $(PX4_MK_DIR)/nuttx.mk
+include $(NAVSTIK_MK_DIR)/nuttx.mk
 
 ################################################################################
 # Modules
 ################################################################################
 
 # where to look for modules
-MODULE_SEARCH_DIRS	+= $(WORK_DIR) $(MODULE_SRC) $(PX4_MODULE_SRC)
+MODULE_SEARCH_DIRS	+= $(WORK_DIR) $(MODULE_SRC) $(NAVSTIK_MODULE_SRC)
 
 # sort and unique the modules list
 MODULES			:= $(sort $(MODULES))
@@ -220,7 +220,7 @@ $(MODULE_OBJS):		mkfile = $(patsubst %module.pre.o,%module.mk,$(relpath))
 $(MODULE_OBJS):		workdir = $(@D)
 $(MODULE_OBJS):		$(GLOBAL_DEPS) $(NUTTX_CONFIG_HEADER)
 	$(Q) $(MKDIR) -p $(workdir)
-	$(Q) $(MAKE) -r -f $(PX4_MK_DIR)module.mk \
+	$(Q) $(MAKE) -r -f $(NAVSTIK_MK_DIR)module.mk \
 		-C $(workdir) \
 		MODULE_WORK_DIR=$(workdir) \
 		MODULE_OBJ=$@ \
@@ -237,7 +237,7 @@ $(MODULE_CLEANS):	relpath = $(patsubst $(WORK_DIR)%,%,$@)
 $(MODULE_CLEANS):	mkfile = $(patsubst %clean,%module.mk,$(relpath))
 $(MODULE_CLEANS):
 	@$(ECHO) %% cleaning using $(mkfile)
-	$(Q) $(MAKE) -r -f $(PX4_MK_DIR)module.mk \
+	$(Q) $(MAKE) -r -f $(NAVSTIK_MK_DIR)module.mk \
 	MODULE_WORK_DIR=$(dir $@) \
 	MODULE_MK=$(mkfile) \
 	clean
@@ -247,7 +247,7 @@ $(MODULE_CLEANS):
 ################################################################################
 
 # where to look for libraries
-LIBRARY_SEARCH_DIRS	+= $(WORK_DIR) $(MODULE_SRC) $(PX4_MODULE_SRC)
+LIBRARY_SEARCH_DIRS	+= $(WORK_DIR) $(MODULE_SRC) $(NAVSTIK_MODULE_SRC)
 
 # sort and unique the library list
 LIBRARIES		:= $(sort $(LIBRARIES))
@@ -280,7 +280,7 @@ $(LIBRARY_LIBS):	mkfile = $(patsubst %library.a,%library.mk,$(relpath))
 $(LIBRARY_LIBS):	workdir = $(@D)
 $(LIBRARY_LIBS):	$(GLOBAL_DEPS) $(NUTTX_CONFIG_HEADER)
 	$(Q) $(MKDIR) -p $(workdir)
-	$(Q) $(MAKE) -r -f $(PX4_MK_DIR)library.mk \
+	$(Q) $(MAKE) -r -f $(NAVSTIK_MK_DIR)library.mk \
 		-C $(workdir) \
 		LIBRARY_WORK_DIR=$(workdir) \
 		LIBRARY_LIB=$@ \
@@ -297,7 +297,7 @@ $(LIBRARY_CLEANS):	relpath = $(patsubst $(WORK_DIR)%,%,$@)
 $(LIBRARY_CLEANS):	mkfile = $(patsubst %clean,%library.mk,$(relpath))
 $(LIBRARY_CLEANS):
 	@$(ECHO) %% cleaning using $(mkfile)
-	$(Q) $(MAKE) -r -f $(PX4_MK_DIR)library.mk \
+	$(Q) $(MAKE) -r -f $(NAVSTIK_MK_DIR)library.mk \
 	LIBRARY_WORK_DIR=$(dir $@) \
 	LIBRARY_MK=$(mkfile) \
 	clean
@@ -428,7 +428,7 @@ endif
 #
 # What we're going to build.
 #
-PRODUCT_BUNDLE		 = $(WORK_DIR)firmware.px4
+PRODUCT_BUNDLE		 = $(WORK_DIR)firmware.navstik
 PRODUCT_BIN		 = $(WORK_DIR)firmware.bin
 PRODUCT_ELF		 = $(WORK_DIR)firmware.elf
 
@@ -462,7 +462,7 @@ $(filter %.S.o,$(OBJS)): $(WORK_DIR)%.S.o: %.S $(GLOBAL_DEPS)
 $(PRODUCT_BUNDLE):	$(PRODUCT_BIN)
 	@$(ECHO) %% Generating $@
 	$(Q) $(MKFW) --prototype $(IMAGE_DIR)/$(BOARD).prototype \
-		--git_identity $(PX4_BASE) \
+		--git_identity $(NAVSTIK_BASE) \
 		--image $< > $@
 
 $(PRODUCT_BIN):		$(PRODUCT_ELF)
@@ -477,7 +477,7 @@ $(PRODUCT_ELF):		$(OBJS) $(MODULE_OBJS) $(LIBRARY_LIBS) $(GLOBAL_DEPS) $(LINK_DE
 
 .PHONY: upload
 upload:	$(PRODUCT_BUNDLE) $(PRODUCT_BIN)
-	$(Q) $(MAKE) -f $(PX4_MK_DIR)/upload.mk \
+	$(Q) $(MAKE) -f $(NAVSTIK_MK_DIR)/upload.mk \
 		METHOD=serial \
 		CONFIG=$(CONFIG) \
 		BOARD=$(BOARD) \
diff --git a/makefiles/library.mk b/makefiles/library.mk
index 28a421f..7c8a60c 100644
--- a/makefiles/library.mk
+++ b/makefiles/library.mk
@@ -30,7 +30,7 @@
 #
 
 #
-# Framework makefile for PX4 libraries
+# Framework makefile for NAVSTIK libraries
 #
 # This makefile is invoked by firmware.mk to build each of the linraries
 # that will subsequently be linked into the firmware image.
@@ -93,7 +93,7 @@ $(info %% LIBRARY_MK          = $(LIBRARY_MK))
 #
 # Get the board/toolchain config
 #
-include $(PX4_MK_DIR)/board_$(BOARD).mk
+include $(NAVSTIK_MK_DIR)/board_$(BOARD).mk
 
 #
 # Get the library's config
diff --git a/makefiles/module.mk b/makefiles/module.mk
index 9e4cbaf..63ed7cc 100644
--- a/makefiles/module.mk
+++ b/makefiles/module.mk
@@ -30,7 +30,7 @@
 #
 
 #
-# Framework makefile for PX4 modules
+# Framework makefile for NAVSTIK modules
 #
 # This makefile is invoked by firmware.mk to build each of the modules
 # that will subsequently be linked into the firmware image.
@@ -117,7 +117,7 @@ $(info %% MODULE_MK           = $(MODULE_MK))
 #
 # Get the board/toolchain config
 #
-include $(PX4_MK_DIR)/board_$(BOARD).mk
+include $(NAVSTIK_MK_DIR)/board_$(BOARD).mk
 
 #
 # Get the module's config
@@ -171,8 +171,8 @@ else
 DEFAULT_VISIBILITY = default
 endif
 
-CFLAGS		+= -fvisibility=$(DEFAULT_VISIBILITY) -include $(PX4_INCLUDE_DIR)visibility.h
-CXXFLAGS	+= -fvisibility=$(DEFAULT_VISIBILITY) -include $(PX4_INCLUDE_DIR)visibility.h
+CFLAGS		+= -fvisibility=$(DEFAULT_VISIBILITY) -include $(NAVSTIK_INCLUDE_DIR)visibility.h
+CXXFLAGS	+= -fvisibility=$(DEFAULT_VISIBILITY) -include $(NAVSTIK_INCLUDE_DIR)visibility.h
 
 ################################################################################
 # Build rules
diff --git a/makefiles/nuttx.mk b/makefiles/nuttx.mk
index d283096..cf6fa07 100644
--- a/makefiles/nuttx.mk
+++ b/makefiles/nuttx.mk
@@ -39,7 +39,7 @@
 #
 NUTTX_ARCHIVE		:= $(wildcard $(ARCHIVE_DIR)$(BOARD).export)
 ifeq ($(NUTTX_ARCHIVE),)
-$(error The NuttX export archive for $(BOARD) is missing from $(ARCHIVE_DIR) - try 'make archives' in $(PX4_BASE))
+$(error The NuttX export archive for $(BOARD) is missing from $(ARCHIVE_DIR) - try 'make archives' in $(NAVSTIK_BASE))
 endif
 
 #
diff --git a/makefiles/setup.mk b/makefiles/setup.mk
index 92461fa..b49c23b 100644
--- a/makefiles/setup.mk
+++ b/makefiles/setup.mk
@@ -41,29 +41,29 @@
 # the number of duplicate slashes we have lying around in paths,
 # and is consistent with joining the results of $(dir) and $(notdir).
 #
-export PX4_INCLUDE_DIR	 = $(abspath $(PX4_BASE)/src/include)/
-export PX4_MODULE_SRC	 = $(abspath $(PX4_BASE)/src)/
-export PX4_MK_DIR	 = $(abspath $(PX4_BASE)/makefiles)/
-export NUTTX_SRC	 = $(abspath $(PX4_BASE)/NuttX/nuttx)/
-export NUTTX_APP_SRC	 = $(abspath $(PX4_BASE)/NuttX/apps)/
-export MAVLINK_SRC	 = $(abspath $(PX4_BASE)/mavlink)/
-export ROMFS_SRC	 = $(abspath $(PX4_BASE)/ROMFS)/
-export IMAGE_DIR	 = $(abspath $(PX4_BASE)/Images)/
-export BUILD_DIR	 = $(abspath $(PX4_BASE)/Build)/
-export ARCHIVE_DIR	 = $(abspath $(PX4_BASE)/Archives)/
+export NAVSTIK_INCLUDE_DIR	 = $(abspath $(NAVSTIK_BASE)/src/include)/
+export NAVSTIK_MODULE_SRC	 = $(abspath $(NAVSTIK_BASE)/src)/
+export NAVSTIK_MK_DIR	 = $(abspath $(NAVSTIK_BASE)/makefiles)/
+export NUTTX_SRC	 = $(abspath $(NAVSTIK_BASE)/NuttX/nuttx)/
+export NUTTX_APP_SRC	 = $(abspath $(NAVSTIK_BASE)/NuttX/apps)/
+export MAVLINK_SRC	 = $(abspath $(NAVSTIK_BASE)/mavlink)/
+export ROMFS_SRC	 = $(abspath $(NAVSTIK_BASE)/ROMFS)/
+export IMAGE_DIR	 = $(abspath $(NAVSTIK_BASE)/Images)/
+export BUILD_DIR	 = $(abspath $(NAVSTIK_BASE)/Build)/
+export ARCHIVE_DIR	 = $(abspath $(NAVSTIK_BASE)/Archives)/
 
 #
 # Default include paths
 #
-export INCLUDE_DIRS	:= $(PX4_MODULE_SRC) \
-			   $(PX4_MODULE_SRC)/modules/ \
-			   $(PX4_INCLUDE_DIR)
+export INCLUDE_DIRS	:= $(NAVSTIK_MODULE_SRC) \
+			   $(NAVSTIK_MODULE_SRC)/modules/ \
+			   $(NAVSTIK_INCLUDE_DIR)
 
 #
 # Tools
 #
-export MKFW		 = $(PX4_BASE)/Tools/px_mkfw.py
-export UPLOADER		 = $(PX4_BASE)/Tools/px_uploader.py
+export MKFW		 = $(NAVSTIK_BASE)/Tools/navstik_mkfw.py
+export UPLOADER		 = $(NAVSTIK_BASE)/Tools/px_uploader.py
 export COPY		 = cp
 export REMOVE		 = rm -f
 export RMDIR		 = rm -rf
diff --git a/makefiles/toolchain_gnu-arm-eabi.mk b/makefiles/toolchain_gnu-arm-eabi.mk
index 3f4d337..128bb6d 100644
--- a/makefiles/toolchain_gnu-arm-eabi.mk
+++ b/makefiles/toolchain_gnu-arm-eabi.mk
@@ -243,6 +243,7 @@ endef
 define LINK
 	@$(ECHO) "LINK:    $1"
 	@$(MKDIR) -p $(dir $1)
+	@$(ECHO) "$(Q) $(LD) $(LDFLAGS) -Map $1.map -o $1 --start-group $2 $(LIBS) $(EXTRA_LIBS) $(LIBGCC) --end-group"
 	$(Q) $(LD) $(LDFLAGS) -Map $1.map -o $1 --start-group $2 $(LIBS) $(EXTRA_LIBS) $(LIBGCC) --end-group
 endef
 
diff --git a/src/drivers/bmp180/bmp180.cpp b/src/drivers/bmp180/bmp180.cpp
new file mode 100644
index 0000000..71bd798
--- /dev/null
+++ b/src/drivers/bmp180/bmp180.cpp
@@ -0,0 +1,1181 @@
+/****************************************************************************
+ *
+ *   Copyright (C) 2013 Navstik Development Team. Based on PX4 port.
+ *
+ *   Copyright (C) 2012 PX4 Development Team. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name PX4 nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/**
+ * @file bmp180.cpp
+ * Driver for the BMP180 barometric pressure sensor connected via I2C.
+ */
+
+#include <nuttx/config.h>
+
+#include <drivers/device/i2c.h>
+
+#include <sys/types.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <semaphore.h>
+#include <string.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <errno.h>
+#include <stdio.h>
+#include <math.h>
+#include <unistd.h>
+
+#include <nuttx/arch.h>
+#include <nuttx/wqueue.h>
+#include <nuttx/clock.h>
+
+#include <arch/board/board.h>
+
+#include <drivers/drv_hrt.h>
+
+#include <systemlib/perf_counter.h>
+#include <systemlib/err.h>
+
+#include <drivers/drv_baro.h>
+
+/* oddly, ERROR is not defined for c++ */
+#ifdef ERROR
+# undef ERROR
+#endif
+static const int ERROR = -1;
+
+#ifndef CONFIG_SCHED_WORKQUEUE
+# error This requires CONFIG_SCHED_WORKQUEUE.
+#endif
+
+/**
+ * Calibration PROM as reported by the device.
+ */
+#pragma pack(push,1)
+struct bmp180_data {
+        uint8_t OSS ;
+  	int16_t DELAY_PRESSURE ;
+  	int16_t DELAY_TEMP ;
+  	int16_t MEASUREMENT_MODE ;
+  	int16_t AC1 ;
+  	int16_t AC2 ;
+  	int16_t AC3 ;
+  	uint16_t AC4 ;
+  	uint16_t AC5 ;
+  	uint16_t AC6 ;
+  	int16_t B1  ;
+  	int16_t B2  ;
+  	int16_t MB  ;
+  	int16_t MC  ;
+  	int16_t MD  ;
+  	float PRESSURE ;
+  	float TEMP ;
+};
+
+#pragma pack(pop)
+
+class BMP180 : public device::I2C
+{
+public:
+	BMP180(int bus);
+	~BMP180();
+
+	virtual int		init();
+
+	virtual ssize_t		read(struct file *filp, char *buffer, size_t buflen);
+	virtual int		ioctl(struct file *filp, int cmd, unsigned long arg);
+
+	/**
+	 * Diagnostics - print some basic information about the driver.
+	 */
+	void			print_info();
+
+protected:
+	virtual int		probe();
+
+private:
+	struct bmp180_data	_data;
+
+	struct work_s		_work;
+	unsigned		_measure_ticks;
+
+	unsigned		_num_reports;
+	volatile unsigned	_next_report;
+	volatile unsigned	_oldest_report;
+	struct baro_report	*_reports;
+
+	bool			_collect_phase;
+	unsigned		_measure_phase;
+
+	/* intermediate temperature values per BMP180 datasheet */
+	int32_t			_TEMP;
+	uint32_t		_UT;
+	int64_t			_OFF;
+	int64_t			_SENS;
+
+	/* altitude conversion calibration */
+	unsigned		_msl_pressure;	/* in kPa */
+
+	orb_advert_t		_baro_topic;
+
+	perf_counter_t		_sample_perf;
+	perf_counter_t		_comms_errors;
+	perf_counter_t		_buffer_overflows;
+
+	/**
+	 * Test whether the device supported by the driver is present at a
+	 * specific address.
+	 *
+	 * @param address	The I2C bus address to probe.
+	 * @return		True if the device is present.
+	 */
+	int			probe_address(uint8_t address);
+
+	/**
+	 * Initialise the automatic measurement state machine and start it.
+	 *
+	 * @note This function is called at open and error time.  It might make sense
+	 *       to make it more aggressive about resetting the bus in case of errors.
+	 */
+	void			start();
+
+	/**
+	 * Stop the automatic measurement state machine.
+	 */
+	void			stop();
+
+	/**
+	 * Perform a poll cycle; collect from the previous measurement
+	 * and start a new one.
+	 *
+	 * This is the heart of the measurement state machine.  This function
+	 * alternately starts a measurement, or collects the data from the
+	 * previous measurement.
+	 *
+	 * When the interval between measurements is greater than the minimum
+	 * measurement interval, a gap is inserted between collection
+	 * and measurement to provide the most recent measurement possible
+	 * at the next interval.
+	 */
+	void			cycle();
+
+	/**
+	 * Static trampoline from the workq context; because we don't have a
+	 * generic workq wrapper yet.
+	 *
+	 * @param arg		Instance pointer for the driver that is polling.
+	 */
+	static void		cycle_trampoline(void *arg);
+
+	/**
+	 * Issue a measurement command for the current state.
+	 *
+	 * @return		OK if the measurement command was successful.
+	 */
+	int			measure();
+
+	/**
+	 * Collect the result of the most recent measurement.
+	 */
+	int			collect();
+
+	/**
+	 * Send a reset command to the BMP180.
+	 *
+	 * This is required after any bus reset.
+	 */
+	int			cmd_reset();
+
+	/**
+	 * Read the BMP180 PROM
+	 *
+	 * @return		OK if the PROM reads successfully.
+	 */
+	int			read_prom();
+
+	/**
+	 * PROM CRC routine ported from BMP180 application note
+	 *
+	 * @param n_prom	Pointer to words read from PROM.
+	 * @return		True if the CRC matches.
+	 */
+	bool			crc4(uint16_t *n_prom);
+
+};
+
+/* helper macro for handling report buffer indices */
+#define INCREMENT(_x, _lim)	do { _x++; if (_x >= _lim) _x = 0; } while(0)
+
+/* helper macro for arithmetic - returns the square of the argument */
+#define POW2(_x)		((_x) * (_x))
+
+/*
+ * BMP180 internal constants and data structures.
+ */
+
+/* internal conversion time: 9.17 ms, so should not be read at rates higher than 100 Hz */
+//#define BMP180_CONVERSION_INTERVAL	10000	/* microseconds */
+#define BMP180_MEASUREMENT_RATIO	3	/* pressure measurements per temperature measurement */
+
+#define BMP180_BUS		NAVSTIK_I2C_BUS_SENSORS
+#define BMP180_ADDRESS		NAVSTIK_I2C_OBDEV_BMP180 /* address select pins pulled high */
+
+#define BMP180_CTL        	0xF4 // Measurement Control Register.
+#define BMP180_ADC_MSB      	0xF6 // Read Only Register. Contains Output Data.
+#define BMP180_ADC_LSB      	0xF7 // Read Only Register. Contains Output Data.
+#define BMP180_ADC_XLSB      	0xF8 // Read Only Register. Contains Output Data.
+#define BMP180_ID        	0xD0 // Read Only Register. Value is 0x55 can be used to check communication.
+#define BMP180_SOFT_RESET        	0xE0 // Write Only Register. If set to 0xB6 performs same sequence as power on reset
+
+#define BMP180_TEMP        	0x2E // Value of Control Register for temperature measurment
+#define BMP180_OSS0        	0x34 // Value of Control Register for Conversion time 4.5ms
+#define BMP180_OSS1        	0x74 // Value of Control Register for Conversion time 7.5ms
+#define BMP180_OSS2        	0xB4 // Value of Control Register for Conversion time 13.5ms
+#define BMP180_OSS3        	0xF4 // Value of Control Register for Conversion time 25.5ms
+
+#define BMP180_PRES        	0x34 // base value for pressure measurement (page 15 of datasheet)
+
+#define ULTRA_LOW_POWER     	0
+#define STANDARD        	1
+#define HIGH_RESOLUTION      	2
+#define ULTRA_HIGH_RESOLUTION  	3
+
+/*
+ * Driver 'main' command.
+ */
+extern "C" __EXPORT int bmp180_main(int argc, char *argv[]);
+
+
+BMP180::BMP180(int bus) :
+	I2C("BMP180", BARO_DEVICE_PATH, bus, 0, 400000),
+	_measure_ticks(0),
+	_num_reports(0),
+	_next_report(0),
+	_oldest_report(0),
+	_reports(nullptr),
+	_collect_phase(false),
+	_measure_phase(0),
+	_TEMP(0),
+	_OFF(0),
+	_SENS(0),
+	_msl_pressure(101325),
+	_baro_topic(-1),
+	_sample_perf(perf_alloc(PC_ELAPSED, "bmp180_read")),
+	_comms_errors(perf_alloc(PC_COUNT, "bmp180_comms_errors")),
+	_buffer_overflows(perf_alloc(PC_COUNT, "bmp180_buffer_overflows"))
+{
+	// enable debug() calls
+	_debug_enabled = true;
+
+	// work_cancel in the dtor will explode if we don't do this...
+	memset(&_work, 0, sizeof(_work));
+}
+
+BMP180::~BMP180()
+{
+	/* make sure we are truly inactive */
+	stop();
+
+	/* free any existing reports */
+	if (_reports != nullptr)
+		delete[] _reports;
+}
+
+int
+BMP180::init()
+{
+	int ret = ERROR;
+
+	/* do I2C init (and probe) first */
+	if (I2C::init() != OK)
+		goto out;
+
+	/* allocate basic report buffers */
+	_num_reports = 2;
+	_reports = new struct baro_report[_num_reports];
+
+	if (_reports == nullptr)
+		goto out;
+
+	_oldest_report = _next_report = 0;
+
+	/* get a publish handle on the baro topic */
+	memset(&_reports[0], 0, sizeof(_reports[0]));
+	_baro_topic = orb_advertise(ORB_ID(sensor_baro), &_reports[0]);
+
+	if (_baro_topic < 0)
+		debug("failed to create sensor_baro object");
+
+	ret = OK;
+out:
+	return ret;
+}
+
+int
+BMP180::probe()
+{
+	_retries = 10;
+
+	if (OK == probe_address(BMP180_ADDRESS)) {
+		_retries = 1;
+		return OK;
+	}
+
+	return -EIO;
+}
+
+int
+BMP180::probe_address(uint8_t address)
+{
+	int	ret;
+	uint8_t bmp_txbuf[2];
+
+	/* select the address we are going to try */
+	set_address(address);
+
+	/* send reset command */
+	if (OK != cmd_reset())
+		return -EIO;
+
+	/* read PROM */
+	if (OK != read_prom())
+		return -EIO;
+
+	_data.DELAY_TEMP = 5000;
+	_data.OSS = STANDARD;
+	_data.MEASUREMENT_MODE = BMP180_OSS1;
+	_data.DELAY_PRESSURE = 9000;
+
+	bmp_txbuf[0] =  BMP180_CTL;
+	bmp_txbuf[1] = _data.MEASUREMENT_MODE;
+	ret = transfer(bmp_txbuf, 2, nullptr, 0);
+	if (OK != ret)
+		perf_count(_comms_errors);
+	usleep(_data.DELAY_PRESSURE);
+
+	return OK;
+}
+
+ssize_t
+BMP180::read(struct file *filp, char *buffer, size_t buflen)
+{
+	unsigned count = buflen / sizeof(struct baro_report);
+	int ret = 0;
+
+	/* buffer must be large enough */
+	if (count < 1)
+		return -ENOSPC;
+
+	/* if automatic measurement is enabled */
+	if (_measure_ticks > 0) {
+
+		/*
+		 * While there is space in the caller's buffer, and reports, copy them.
+		 * Note that we may be pre-empted by the workq thread while we are doing this;
+		 * we are careful to avoid racing with them.
+		 */
+		while (count--) {
+			if (_oldest_report != _next_report) {
+				memcpy(buffer, _reports + _oldest_report, sizeof(*_reports));
+				ret += sizeof(_reports[0]);
+				INCREMENT(_oldest_report, _num_reports);
+			}
+		}
+
+		/* if there was no data, warn the caller */
+		return ret ? ret : -EAGAIN;
+	}
+
+	/* manual measurement - run one conversion */
+	/* XXX really it'd be nice to lock against other readers here */
+	do {
+		_measure_phase = 0;
+		_oldest_report = _next_report = 0;
+
+		/* do temperature first */
+		if (OK != measure()) {
+			ret = -EIO;
+			break;
+		}
+
+		usleep(_data.DELAY_TEMP);
+
+		if (OK != collect()) {
+			ret = -EIO;
+			break;
+		}
+
+		/* now do a pressure measurement */
+		if (OK != measure()) {
+			ret = -EIO;
+			break;
+		}
+
+		usleep(_data.DELAY_PRESSURE);
+
+		if (OK != collect()) {
+			ret = -EIO;
+			break;
+		}
+
+		/* state machine will have generated a report, copy it out */
+		memcpy(buffer, _reports, sizeof(*_reports));
+		ret = sizeof(*_reports);
+
+	} while (0);
+
+	return ret;
+}
+
+int
+BMP180::ioctl(struct file *filp, int cmd, unsigned long arg)
+{
+	switch (cmd) {
+
+	case SENSORIOCSPOLLRATE: {
+			switch (arg) {
+
+				/* switching to manual polling */
+			case SENSOR_POLLRATE_MANUAL:
+				stop();
+				_measure_ticks = 0;
+				return OK;
+
+				/* external signalling not supported */
+			case SENSOR_POLLRATE_EXTERNAL:
+
+				/* zero would be bad */
+			case 0:
+				return -EINVAL;
+
+				/* set default/max polling rate */
+			case SENSOR_POLLRATE_MAX:
+			case SENSOR_POLLRATE_DEFAULT: {
+					/* do we need to start internal polling? */
+					bool want_start = (_measure_ticks == 0);
+
+					/* set interval for next measurement to minimum legal value */
+					_measure_ticks = USEC2TICK(_data.DELAY_PRESSURE);
+
+					/* if we need to start the poll state machine, do it */
+					if (want_start)
+						start();
+
+					return OK;
+				}
+
+				/* adjust to a legal polling interval in Hz */
+			default: {
+					/* do we need to start internal polling? */
+					bool want_start = (_measure_ticks == 0);
+
+					/* convert hz to tick interval via microseconds */
+					unsigned ticks = USEC2TICK(1000000 / arg);
+
+					/* check against maximum rate */
+					if (ticks < USEC2TICK(_data.DELAY_PRESSURE))
+						return -EINVAL;
+
+					/* update interval for next measurement */
+					_measure_ticks = ticks;
+
+					/* if we need to start the poll state machine, do it */
+					if (want_start)
+						start();
+
+					return OK;
+				}
+			}
+		}
+
+	case SENSORIOCGPOLLRATE:
+		if (_measure_ticks == 0)
+			return SENSOR_POLLRATE_MANUAL;
+
+		return (1000 / _measure_ticks);
+
+	case SENSORIOCSQUEUEDEPTH: {
+			/* add one to account for the sentinel in the ring */
+			arg++;
+
+			/* lower bound is mandatory, upper bound is a sanity check */
+			if ((arg < 2) || (arg > 100))
+				return -EINVAL;
+
+			/* allocate new buffer */
+			struct baro_report *buf = new struct baro_report[arg];
+
+			if (nullptr == buf)
+				return -ENOMEM;
+
+			/* reset the measurement state machine with the new buffer, free the old */
+			stop();
+			delete[] _reports;
+			_num_reports = arg;
+			_reports = buf;
+			start();
+
+			return OK;
+		}
+
+	case SENSORIOCGQUEUEDEPTH:
+		return _num_reports - 1;
+
+	case SENSORIOCRESET:
+		/* XXX implement this */
+		return -EINVAL;
+
+	case BAROIOCSMSLPRESSURE:
+
+		/* range-check for sanity */
+		if ((arg < 80000) || (arg > 120000))
+			return -EINVAL;
+
+		_msl_pressure = arg;
+		return OK;
+
+	case BAROIOCGMSLPRESSURE:
+		return _msl_pressure;
+
+	default:
+		break;
+	}
+
+	/* give it to the superclass */
+	return I2C::ioctl(filp, cmd, arg);
+}
+
+void
+BMP180::start()
+{
+
+	/* reset the report ring and state machine */
+	_collect_phase = false;
+	_measure_phase = 0;
+	_oldest_report = _next_report = 0;
+
+	/* schedule a cycle to start things */
+	work_queue(HPWORK, &_work, (worker_t)&BMP180::cycle_trampoline, this, 1);
+}
+
+void
+BMP180::stop()
+{
+	work_cancel(HPWORK, &_work);
+}
+
+void
+BMP180::cycle_trampoline(void *arg)
+{
+	BMP180 *dev = (BMP180 *)arg;
+
+	dev->cycle();
+}
+
+void
+BMP180::cycle()
+{
+
+	/* collection phase? */
+	if (_collect_phase) {
+
+		/* perform collection */
+		if (OK != collect()) {
+			log("collection error");
+			/* reset the collection state machine and try again */
+			start();
+			return;
+		}
+
+		/* next phase is measurement */
+		_collect_phase = false;
+
+		/*
+		 * Is there a collect->measure gap?
+		 * Don't inject one after temperature measurements, so we can keep
+		 * doing pressure measurements at something close to the desired rate.
+		 */
+		if ((_measure_phase != 0) &&
+		    (_measure_ticks > USEC2TICK(_data.DELAY_PRESSURE))) {
+
+			/* schedule a fresh cycle call when we are ready to measure again */
+			work_queue(HPWORK,
+				   &_work,
+				   (worker_t)&BMP180::cycle_trampoline,
+				   this,
+				   _measure_ticks - USEC2TICK(_data.DELAY_PRESSURE));
+
+			return;
+		}
+	}
+
+	/* measurement phase */
+	if (OK != measure()) {
+		/* 
+		 * We failed to send the I2C command to start the next
+		 * reading. Hopefully this is a transient bus
+		 * error. Schedule a fresh cycle call to try the
+		 * command again in one tick
+		 */		
+		log("measure error");
+		work_queue(HPWORK,
+			   &_work,
+			   (worker_t)&BMP180::cycle_trampoline,
+			   this, 1);
+		return;
+	}
+
+	/* next phase is collection */
+	_collect_phase = true;
+
+	/* schedule a fresh cycle call when the measurement is done */
+	work_queue(HPWORK,
+		   &_work,
+		   (worker_t)&BMP180::cycle_trampoline,
+		   this,
+		   USEC2TICK(_data.DELAY_PRESSURE));
+}
+
+int
+BMP180::measure()
+{
+	int ret;
+
+	/*
+	 * In phase zero, request temperature; in other phases, request pressure.
+	 */
+	//uint8_t	cmd_data = (_measure_phase == 0) ? ADDR_CMD_CONVERT_D2 : ADDR_CMD_CONVERT_D1;
+	uint8_t bmp_txbuf[2];
+
+	bmp_txbuf[0] = BMP180_CTL;
+	bmp_txbuf[1] = (_measure_phase == 0) ? BMP180_TEMP : (BMP180_PRES + (_data.OSS << 6));
+
+	/*
+	 * Send the command to begin measuring.
+	 */
+	ret = transfer(bmp_txbuf, 2, nullptr, 0);
+
+	if (OK != ret)
+		perf_count(_comms_errors);
+
+	return ret;
+}
+
+int
+BMP180::collect()
+{
+  	uint8_t bmp_txbuf[1], bmp_rxbuf[3] ;
+	
+	perf_begin(_sample_perf);
+
+	/* this should be fairly close to the end of the conversion, so the best approximation of the time */
+	_reports[_next_report].timestamp = hrt_absolute_time();
+
+//	if (OK != transfer(&cmd, 1, &data[0], 3)) {
+//		perf_count(_comms_errors);
+//		return -EIO;
+//   	}
+
+    	bmp_txbuf[0] = BMP180_ADC_MSB ;
+	/* handle a measurement */
+	if (_measure_phase == 0) {
+    		uint32_t ut ;
+    		int32_t x1, x2, b5 ;
+		if (OK != transfer(bmp_txbuf, 1, bmp_rxbuf, 2)) {
+	              perf_count(_comms_errors);
+        	      return -EIO;
+		}
+
+		ut = (bmp_rxbuf[0] << 8) + bmp_rxbuf[1] ;
+    		/*All calculations here are black magic from the
+     		*BMP180 Datasheet. DO NOT CHANGE.
+     		*/
+    		x1 = (ut - _data.AC6) * _data.AC5 >> 15 ;
+    		x2 = ((int32_t)_data.MC << 11) / (x1 + _data.MD) ;
+    		b5 = x1 + x2 ;
+    		_data.TEMP = (float)((b5 + 8) >> 4) / 10.0f;
+		_TEMP = _data.TEMP*100;
+		_UT = ut;
+  	} else {
+		int32_t x1, x2, x3, b3, b5, b6, p ;
+    		uint32_t b4, b7, up, ut ;
+
+		if (OK != transfer(bmp_txbuf, 1, bmp_rxbuf, 3)) {
+                      perf_count(_comms_errors);
+                      return -EIO;
+		}
+		
+		ut = _UT;		
+		up = ((bmp_rxbuf[0] << 16) + (bmp_rxbuf[1] << 8) + bmp_rxbuf[2]) >> (8 - _data.OSS) ;
+      		x1 = (ut - _data.AC6) * _data.AC5 >> 15 ;
+      		x2 = ((int32_t)_data.MC << 11) / (x1 + _data.MD) ;
+      		b5 = x1 + x2 ;
+      		
+		b6 = b5 - 4000 ;
+      		x1 = (_data.B2 * (b6 * b6 >> 12)) >> 11 ;
+      		x2 = _data.AC2 * b6 >> 11 ;
+      		x3 = x1 + x2 ;
+      		b3 = ((((int32_t)_data.AC1 * 4 + x3) << _data.OSS) + 2) >> 2 ;
+
+      		x1 = _data.AC3 * b6 >> 13 ;
+      		x2 = (_data.B1 * (b6 * b6 >> 12)) >> 16 ;
+      		x3 = ((x1 + x2) + 2) >> 2 ;
+      		b4 = (_data.AC4 * (uint32_t)(x3 + 32768)) >> 15 ;
+      		b7 = ((uint32_t)up - b3) * (50000 >> _data.OSS) ;
+
+      		if(b7 < 0x80000000)
+        		p = (b7 * 2) / b4 ;
+      		else
+        		p = (b7 / b4) * 2 ;
+
+      		x1 = (p >> 8) * (p >> 8) ;
+      		x1 = (x1 * 3038) >> 16 ;
+      		x2 = (-7357 * p) >> 16 ;
+      		_data.PRESSURE = (float)(p + ((x1 + x2 + 3791) >> 4)) ;
+
+		/* pressure calculation, result in Pa */
+		int32_t P = _data.PRESSURE;
+
+		/* generate a new report */
+		_reports[_next_report].temperature = _TEMP / 100.0f;
+		_reports[_next_report].pressure = P / 100.0f;		/* convert to millibar */
+
+		/* altitude calculations based on http://www.kansasflyer.org/index.asp?nav=Avi&sec=Alti&tab=Theory&pg=1 */
+
+		/*
+		 * PERFORMANCE HINT:
+		 *
+		 * The single precision calculation is 50 microseconds faster than the double
+		 * precision variant. It is however not obvious if double precision is required.
+		 * Pending more inspection and tests, we'll leave the double precision variant active.
+		 *
+		 * Measurements:
+		 * 	double precision: bmp180_read: 992 events, 258641us elapsed, min 202us max 305us
+		 *	single precision: bmp180_read: 963 events, 208066us elapsed, min 202us max 241us
+		 */
+#if 0/* USE_FLOAT */
+		/* tropospheric properties (0-11km) for standard atmosphere */
+		const float T1 = 15.0f + 273.15f;	/* temperature at base height in Kelvin */
+		const float a  = -6.5f / 1000f;	/* temperature gradient in degrees per metre */
+		const float g  = 9.80665f;	/* gravity constant in m/s/s */
+		const float R  = 287.05f;	/* ideal gas constant in J/kg/K */
+
+		/* current pressure at MSL in kPa */
+		float p1 = _msl_pressure / 1000.0f;
+
+		/* measured pressure in kPa */
+		float p = P / 1000.0f;
+
+		/*
+		 * Solve:
+		 *
+		 *     /        -(aR / g)     \
+		 *    | (p / p1)          . T1 | - T1
+		 *     \                      /
+		 * h = -------------------------------  + h1
+		 *                   a
+		 */
+		_reports[_next_report].altitude = (((powf((p / p1), (-(a * R) / g))) * T1) - T1) / a;
+#else
+		/* tropospheric properties (0-11km) for standard atmosphere */
+		const double T1 = 15.0 + 273.15;	/* temperature at base height in Kelvin */
+		const double a  = -6.5 / 1000;	/* temperature gradient in degrees per metre */
+		const double g  = 9.80665;	/* gravity constant in m/s/s */
+		const double R  = 287.05;	/* ideal gas constant in J/kg/K */
+
+		/* current pressure at MSL in kPa */
+		double p1 = _msl_pressure / 1000.0;
+
+		/* measured pressure in kPa */
+		double pp = P / 1000.0;
+
+		/*
+		 * Solve:
+		 *
+		 *     /        -(aR / g)     \
+		 *    | (p / p1)          . T1 | - T1
+		 *     \                      /
+		 * h = -------------------------------  + h1
+		 *                   a
+		 */
+		_reports[_next_report].altitude = (((pow((pp / p1), (-(a * R) / g))) * T1) - T1) / a;
+#endif
+		/* publish it */
+		orb_publish(ORB_ID(sensor_baro), _baro_topic, &_reports[_next_report]);
+
+		/* post a report to the ring - note, not locked */
+		INCREMENT(_next_report, _num_reports);
+
+		/* if we are running up against the oldest report, toss it */
+		if (_next_report == _oldest_report) {
+			perf_count(_buffer_overflows);
+			INCREMENT(_oldest_report, _num_reports);
+		}
+
+		/* notify anyone waiting for data */
+		poll_notify(POLLIN);
+	}
+
+	/* update the measurement state machine */
+	INCREMENT(_measure_phase, BMP180_MEASUREMENT_RATIO + 1);
+
+	perf_end(_sample_perf);
+
+	return OK;
+}
+
+int
+BMP180::cmd_reset()
+{
+	unsigned	old_retrycount = _retries;
+	uint8_t		bmp_txbuf[2];
+	int		result;
+	
+	bmp_txbuf[0] = BMP180_SOFT_RESET; 
+	bmp_txbuf[1] = 0xB6;
+
+	/* bump the retry count */
+	_retries = 10;
+	result = transfer(bmp_txbuf, 2, nullptr, 0);
+	_retries = old_retrycount;
+
+	return result;
+}
+
+int
+BMP180::read_prom()
+{
+
+	uint8_t bmp_txbuf[1], bmp_rxbuf[22] ;
+
+	usleep(10000);
+  
+	bmp_txbuf[0] = 0xAA ;
+
+	if (OK == transfer(bmp_txbuf, 1, bmp_rxbuf, 22)) {
+		_data.AC1 = (bmp_rxbuf[0] << 8) + bmp_rxbuf[1] ;    /*AC1 */
+   		_data.AC2 = (bmp_rxbuf[2] << 8) + bmp_rxbuf[3] ;    /*AC2 */
+  		_data.AC3 = (bmp_rxbuf[4] << 8) + bmp_rxbuf[5] ;    /*AC3 */
+  		_data.AC4 = (bmp_rxbuf[6] << 8) + bmp_rxbuf[7] ;    /*AC4 */
+  		_data.AC5 = (bmp_rxbuf[8] << 8) + bmp_rxbuf[9] ;    /*AC5 */
+  		_data.AC6 = (bmp_rxbuf[10] << 8) + bmp_rxbuf[11] ;    /*AC6 */
+  		_data.B1  = (bmp_rxbuf[12] << 8) + bmp_rxbuf[13] ;    /*B1 */
+  		_data.B2  = (bmp_rxbuf[14] << 8) + bmp_rxbuf[15] ;    /*B2 */
+  		_data.MB  = (bmp_rxbuf[16] << 8) + bmp_rxbuf[17] ;    /*MB */
+  		_data.MC  = (bmp_rxbuf[18] << 8) + bmp_rxbuf[19] ;    /*MC */
+  		_data.MD  = (bmp_rxbuf[20] << 8) + bmp_rxbuf[21] ;    /*MD */
+	}
+	return OK;
+}
+
+void
+BMP180::print_info()
+{
+	perf_print_counter(_sample_perf);
+	perf_print_counter(_comms_errors);
+	perf_print_counter(_buffer_overflows);
+	printf("poll interval:  %u ticks\n", _measure_ticks);
+	printf("report queue:   %u (%u/%u @ %p)\n",
+	       _num_reports, _oldest_report, _next_report, _reports);
+	printf("TEMP:           %d\n", _TEMP);
+	printf("SENS:           %lld\n", _SENS);
+	printf("OFF:            %lld\n", _OFF);
+	printf("MSL pressure:   %10.4f\n", (double)(_msl_pressure / 100.f));
+}
+
+/**
+ * Local functions in support of the shell command.
+ */
+namespace bmp180
+{
+
+BMP180	*g_dev;
+
+void	start();
+void	test();
+void	reset();
+void	info();
+void	calibrate(unsigned altitude);
+
+/**
+ * Start the driver.
+ */
+void
+start()
+{
+	int fd;
+
+	if (g_dev != nullptr)
+		errx(1, "already started");
+
+	/* create the driver */
+	g_dev = new BMP180(BMP180_BUS);
+
+	if (g_dev == nullptr)
+		goto fail;
+
+	if (OK != g_dev->init())
+		goto fail;
+
+	/* set the poll rate to default, starts automatic data collection */
+	fd = open(BARO_DEVICE_PATH, O_RDONLY);
+
+	if (fd < 0)
+		goto fail;
+
+	if (ioctl(fd, SENSORIOCSPOLLRATE, SENSOR_POLLRATE_DEFAULT) < 0)
+		goto fail;
+
+	exit(0);
+
+fail:
+
+	if (g_dev != nullptr) {
+		delete g_dev;
+		g_dev = nullptr;
+	}
+
+	errx(1, "driver start failed");
+}
+
+/**
+ * Perform some basic functional tests on the driver;
+ * make sure we can collect data from the sensor in polled
+ * and automatic modes.
+ */
+void
+test()
+{
+	struct baro_report report;
+	ssize_t sz;
+	int ret;
+
+	int fd = open(BARO_DEVICE_PATH, O_RDONLY);
+
+	if (fd < 0)
+		err(1, "%s open failed (try 'bmp180 start' if the driver is not running)", BARO_DEVICE_PATH);
+
+	/* do a simple demand read */
+	sz = read(fd, &report, sizeof(report));
+
+	if (sz != sizeof(report))
+		err(1, "immediate read failed");
+
+	warnx("single read");
+	warnx("pressure:    %10.4f", (double)report.pressure);
+	warnx("altitude:    %11.4f", (double)report.altitude);
+	warnx("temperature: %8.4f", (double)report.temperature);
+	warnx("time:        %lld", report.timestamp);
+
+	/* set the queue depth to 10 */
+	if (OK != ioctl(fd, SENSORIOCSQUEUEDEPTH, 10))
+		errx(1, "failed to set queue depth");
+
+	/* start the sensor polling at 2Hz */
+	if (OK != ioctl(fd, SENSORIOCSPOLLRATE, 2))
+		errx(1, "failed to set 2Hz poll rate");
+
+	/* read the sensor 5x and report each value */
+	for (unsigned i = 0; i < 15; i++) {
+		struct pollfd fds;
+
+		/* wait for data to be ready */
+		fds.fd = fd;
+		fds.events = POLLIN;
+		ret = poll(&fds, 1, 2000);
+
+		if (ret != 1)
+			errx(1, "timed out waiting for sensor data");
+
+		/* now go get it */
+		sz = read(fd, &report, sizeof(report));
+
+		if (sz != sizeof(report))
+			err(1, "periodic read failed");
+
+		warnx("periodic read %u", i);
+		warnx("pressure:    %10.4f", (double)report.pressure);
+		warnx("altitude:    %11.4f", (double)report.altitude);
+		warnx("temperature: %8.4f", (double)report.temperature);
+		warnx("time:        %lld", report.timestamp);
+	}
+
+	errx(0, "PASS");
+}
+
+/**
+ * Reset the driver.
+ */
+void
+reset()
+{
+	int fd = open(BARO_DEVICE_PATH, O_RDONLY);
+
+	if (fd < 0)
+		err(1, "failed ");
+
+	if (ioctl(fd, SENSORIOCRESET, 0) < 0)
+		err(1, "driver reset failed");
+
+	if (ioctl(fd, SENSORIOCSPOLLRATE, SENSOR_POLLRATE_DEFAULT) < 0)
+		err(1, "driver poll restart failed");
+
+	exit(0);
+}
+
+/**
+ * Print a little info about the driver.
+ */
+void
+info()
+{
+	if (g_dev == nullptr)
+		errx(1, "driver not running");
+
+	printf("state @ %p\n", g_dev);
+	g_dev->print_info();
+
+	exit(0);
+}
+
+/**
+ * Calculate actual MSL pressure given current altitude
+ */
+void
+calibrate(unsigned altitude)
+{
+	struct baro_report report;
+	float	pressure;
+	float	p1;
+
+	int fd = open(BARO_DEVICE_PATH, O_RDONLY);
+
+	if (fd < 0)
+		err(1, "%s open failed (try 'bmp180 start' if the driver is not running)", BARO_DEVICE_PATH);
+
+	/* start the sensor polling at max */
+	if (OK != ioctl(fd, SENSORIOCSPOLLRATE, SENSOR_POLLRATE_MAX))
+		errx(1, "failed to set poll rate");
+
+	/* average a few measurements */
+	pressure = 0.0f;
+
+	for (unsigned i = 0; i < 20; i++) {
+		struct pollfd fds;
+		int ret;
+		ssize_t sz;
+
+		/* wait for data to be ready */
+		fds.fd = fd;
+		fds.events = POLLIN;
+		ret = poll(&fds, 1, 1000);
+
+		if (ret != 1)
+			errx(1, "timed out waiting for sensor data");
+
+		/* now go get it */
+		sz = read(fd, &report, sizeof(report));
+
+		if (sz != sizeof(report))
+			err(1, "sensor read failed");
+
+		pressure += report.pressure;
+	}
+
+	pressure /= 20;		/* average */
+	pressure /= 10;		/* scale from millibar to kPa */
+
+	/* tropospheric properties (0-11km) for standard atmosphere */
+	const float T1 = 15.0 + 273.15;	/* temperature at base height in Kelvin */
+	const float a  = -6.5 / 1000;	/* temperature gradient in degrees per metre */
+	const float g  = 9.80665f;	/* gravity constant in m/s/s */
+	const float R  = 287.05f;	/* ideal gas constant in J/kg/K */
+
+	warnx("averaged pressure %10.4fkPa at %um", pressure, altitude);
+
+	p1 = pressure * (powf(((T1 + (a * (float)altitude)) / T1), (g / (a * R))));
+
+	warnx("calculated MSL pressure %10.4fkPa", p1);
+
+	/* save as integer Pa */
+	p1 *= 1000.0f;
+
+	if (ioctl(fd, BAROIOCSMSLPRESSURE, (unsigned long)p1) != OK)
+		err(1, "BAROIOCSMSLPRESSURE");
+
+	exit(0);
+}
+
+} // namespace
+
+int
+bmp180_main(int argc, char *argv[])
+{
+	/*
+	 * Start/load the driver.
+	 */
+	if (!strcmp(argv[1], "start"))
+		bmp180::start();
+
+	/*
+	 * Test the driver/device.
+	 */
+	if (!strcmp(argv[1], "test"))
+		bmp180::test();
+
+	/*
+	 * Reset the driver.
+	 */
+	if (!strcmp(argv[1], "reset"))
+		bmp180::reset();
+
+	/*
+	 * Print driver information.
+	 */
+	if (!strcmp(argv[1], "info"))
+		bmp180::info();
+
+	/*
+	 * Perform MSL pressure calibration given an altitude in metres
+	 */
+	if (!strcmp(argv[1], "calibrate")) {
+		if (argc < 2)
+			errx(1, "missing altitude");
+
+		long altitude = strtol(argv[2], nullptr, 10);
+
+		bmp180::calibrate(altitude);
+	}
+
+	errx(1, "unrecognised command, try 'start', 'test', 'reset' or 'info'");
+}
diff --git a/src/drivers/bmp180/module.mk b/src/drivers/bmp180/module.mk
new file mode 100644
index 0000000..c9097bc
--- /dev/null
+++ b/src/drivers/bmp180/module.mk
@@ -0,0 +1,8 @@
+#
+# Makefile to build the BMP180 driver.
+#
+
+APPNAME		 = bmp180
+PRIORITY	 = SCHED_PRIORITY_DEFAULT
+STACKSIZE	 = 2048
+SRCS		= bmp180.cpp
diff --git a/src/drivers/boards/navstik/module.mk b/src/drivers/boards/navstik/module.mk
new file mode 100644
index 0000000..f78375b
--- /dev/null
+++ b/src/drivers/boards/navstik/module.mk
@@ -0,0 +1,11 @@
+#
+# Board-specific startup code for Navstik
+#
+
+SRCS		 = navstik_can.c \
+		   navstik_init.c \
+		   navstik_pwm_servo.c \
+		   navstik_spi.c \
+		   navstik_usb.c \
+		   navstik_led.c
+
diff --git a/src/drivers/boards/navstik/navstik_can.c b/src/drivers/boards/navstik/navstik_can.c
new file mode 100644
index 0000000..6b35cb5
--- /dev/null
+++ b/src/drivers/boards/navstik/navstik_can.c
@@ -0,0 +1,141 @@
+/****************************************************************************
+ *
+ *   Copyright (C) 2012 PX4 Development Team. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name PX4 nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/**
+ * @file navstik_can.c
+ *
+ * Board-specific CAN functions.
+ */
+
+
+/************************************************************************************
+ * Included Files
+ ************************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <errno.h>
+#include <debug.h>
+
+#include <nuttx/can.h>
+#include <arch/board/board.h>
+
+#include "chip.h"
+#include "up_arch.h"
+
+#include "stm32.h"
+#include "stm32_can.h"
+#include "navstik_internal.h"
+
+/************************************************************************************
+ * Pre-processor Definitions
+ ************************************************************************************/
+/* Configuration ********************************************************************/
+
+#if defined(CONFIG_STM32_CAN1) && defined(CONFIG_STM32_CAN2)
+#  warning "Both CAN1 and CAN2 are enabled.  Assuming only CAN1."
+#  undef CONFIG_STM32_CAN2
+#endif
+
+#ifdef CONFIG_STM32_CAN1
+#  define CAN_PORT 1
+#else
+#  define CAN_PORT 2
+#endif
+
+/* Debug ***************************************************************************/
+/* Non-standard debug that may be enabled just for testing CAN */
+
+#ifdef CONFIG_DEBUG_CAN
+#  define candbg    dbg
+#  define canvdbg   vdbg
+#  define canlldbg  lldbg
+#  define canllvdbg llvdbg
+#else
+#  define candbg(x...)
+#  define canvdbg(x...)
+#  define canlldbg(x...)
+#  define canllvdbg(x...)
+#endif
+
+/************************************************************************************
+ * Private Functions
+ ************************************************************************************/
+
+/************************************************************************************
+ * Public Functions
+ ************************************************************************************/
+
+/************************************************************************************
+ * Name: can_devinit
+ *
+ * Description:
+ *   All STM32 architectures must provide the following interface to work with
+ *   examples/can.
+ *
+ ************************************************************************************/
+
+int can_devinit(void)
+{
+	static bool initialized = false;
+	struct can_dev_s *can;
+	int ret;
+
+	/* Check if we have already initialized */
+
+	if (!initialized) {
+		/* Call stm32_caninitialize() to get an instance of the CAN interface */
+
+		can = stm32_caninitialize(CAN_PORT);
+
+		if (can == NULL) {
+			candbg("ERROR:  Failed to get CAN interface\n");
+			return -ENODEV;
+		}
+
+		/* Register the CAN driver at "/dev/can0" */
+
+		ret = can_register("/dev/can0", can);
+
+		if (ret < 0) {
+			candbg("ERROR: can_register failed: %d\n", ret);
+			return ret;
+		}
+
+		/* Now we are initialized */
+
+		initialized = true;
+	}
+
+	return OK;
+}
diff --git a/src/drivers/boards/navstik/navstik_init.c b/src/drivers/boards/navstik/navstik_init.c
new file mode 100644
index 0000000..c9747c7
--- /dev/null
+++ b/src/drivers/boards/navstik/navstik_init.c
@@ -0,0 +1,230 @@
+/****************************************************************************
+ *
+ *   Copyright (C) 2013 Navstik Development Team. Based on PX4 port.
+ *
+ *   Copyright (C) 2012 PX4 Development Team. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name PX4 nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/**
+ * @file navstik_init.c
+ *
+ * Navstik-specific early startup code.  This file implements the
+ * nsh_archinitialize() function that is called early by nsh during startup.
+ *
+ * Code here is run before the rcS script is invoked; it should start required
+ * subsystems and perform board-specific initialisation.
+ */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdbool.h>
+#include <stdio.h>
+#include <debug.h>
+#include <errno.h>
+
+#include <nuttx/arch.h>
+#include <nuttx/spi.h>
+#include <nuttx/i2c.h>
+#include <nuttx/mmcsd.h>
+#include <nuttx/analog/adc.h>
+
+#include "stm32.h"
+#include "navstik_internal.h"
+#include "stm32_uart.h"
+
+#include <arch/board/board.h>
+
+#include <drivers/drv_hrt.h>
+#include <drivers/drv_led.h>
+
+#include <systemlib/cpuload.h>
+
+/****************************************************************************
+ * Pre-Processor Definitions
+ ****************************************************************************/
+
+/* Configuration ************************************************************/
+
+/* Debug ********************************************************************/
+
+#ifdef CONFIG_CPP_HAVE_VARARGS
+#  ifdef CONFIG_DEBUG
+#    define message(...) lib_lowprintf(__VA_ARGS__)
+#  else
+#    define message(...) printf(__VA_ARGS__)
+#  endif
+#else
+#  ifdef CONFIG_DEBUG
+#    define message lib_lowprintf
+#  else
+#    define message printf
+#  endif
+#endif
+
+/****************************************************************************
+ * Protected Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/************************************************************************************
+ * Name: stm32_boardinitialize
+ *
+ * Description:
+ *   All STM32 architectures must provide the following entry point.  This entry point
+ *   is called early in the intitialization -- after all memory has been configured
+ *   and mapped but before any devices have been initialized.
+ *
+ ************************************************************************************/
+
+__EXPORT void stm32_boardinitialize(void)
+{
+	/* configure SPI interfaces */
+	stm32_spiinitialize();
+
+	/* configure LEDs */
+	up_ledinit();
+}
+
+/****************************************************************************
+ * Name: nsh_archinitialize
+ *
+ * Description:
+ *   Perform architecture specific initialization
+ *
+ ****************************************************************************/
+
+static struct spi_dev_s *spi2;
+
+#include <math.h>
+
+#ifdef __cplusplus
+__EXPORT int matherr(struct __exception *e)
+{
+	return 1;
+}
+#else
+__EXPORT int matherr(struct exception *e)
+{
+	return 1;
+}
+#endif
+
+__EXPORT int nsh_archinitialize(void)
+{
+	int result;
+	
+	/* Enable power to peripherals suchg as Telemetry, GPS, Sensors i.e. enable PC10, PA4, PC15 */
+
+        stm32_configgpio(GPIO_SENSOR_PWR_EN);
+        stm32_gpiowrite(GPIO_SENSOR_PWR_EN, true);
+
+        stm32_configgpio(GPIO_GPS_PWR_EN);
+        stm32_gpiowrite(GPIO_GPS_PWR_EN, true);
+
+        stm32_configgpio(GPIO_TELE_PWR_EN);
+        stm32_gpiowrite(GPIO_TELE_PWR_EN, true);
+
+	/* configure the high-resolution time/callout interface */
+	hrt_init();
+
+	/* configure CPU load estimation */
+#ifdef CONFIG_SCHED_INSTRUMENTATION
+	cpuload_initialize_once();
+#endif
+
+	/* set up the serial DMA polling */
+	static struct hrt_call serial_dma_call;
+	struct timespec ts;
+
+	/*
+	 * Poll at 1ms intervals for received bytes that have not triggered
+	 * a DMA event.
+	 */
+	ts.tv_sec = 0;
+	ts.tv_nsec = 1000000;
+
+	hrt_call_every(&serial_dma_call,
+		       ts_to_abstime(&ts),
+		       ts_to_abstime(&ts),
+		       (hrt_callout)stm32_serial_dma_poll,
+		       NULL);
+
+	// initial LED state
+	drv_led_start();
+	up_ledoff(LED_BLUE);
+	up_ledoff(LED_AMBER);
+	up_ledon(LED_BLUE);
+
+	/* Configure SPI-based devices */
+
+	spi2 = up_spiinitialize(2);
+
+	if (!spi2) {
+		message("[boot] FAILED to initialize SPI port 2\r\n");
+		up_ledon(LED_AMBER);
+		return -ENODEV;
+	}
+
+	// Default SPI2 to 1MHz and de-assert the known chip selects.
+	//SPI_SETFREQUENCY(spi2, 10000000);
+	//SPI_SETBITS(spi2, 8);
+	//SPI_SETMODE(spi2, SPIDEV_MODE3);
+	//SPI_SELECT(spi2, NAVSTIK_SPIDEV_FLASH, false);
+	//SPI_SELECT(spi2, NAVSTIK_SPIDEV_SDCARD, false);
+	//up_udelay(20);
+
+	SPI_SELECT(spi2, NAVSTIK_SPIDEV_FLASH, false);
+	message("[boot] Successfully initialized SPI port 2\r\n");
+
+	/* Now bind the SPI interface to the MMCSD driver */
+	result = mmcsd_spislotinitialize(CONFIG_NSH_MMCSDMINOR, CONFIG_NSH_MMCSDSLOTNO, spi2);
+
+	if (result != OK) {
+		message("[boot] FAILED to bind SPI port 2 to the MMCSD driver\n");
+		up_ledon(LED_AMBER);
+		return -ENODEV;
+	}
+	message("[boot] Successfully bound SPI port 2 to the MMCSD driver\n");
+
+	stm32_configgpio(GPIO_ADC1_IN1);
+	stm32_configgpio(GPIO_ADC1_IN11);
+//	stm32_configgpio(GPIO_ADC1_IN12);
+//	stm32_configgpio(GPIO_ADC1_IN13);	// jumperable to MPU6000 DRDY on some boards
+
+	return OK;
+}
diff --git a/src/drivers/boards/navstik/navstik_internal.h b/src/drivers/boards/navstik/navstik_internal.h
new file mode 100644
index 0000000..be077da
--- /dev/null
+++ b/src/drivers/boards/navstik/navstik_internal.h
@@ -0,0 +1,140 @@
+/****************************************************************************
+ *
+ *   Copyright (C) 2012 PX4 Development Team. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name PX4 nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/**
+ * @file navstik_internal.h
+ *
+ * Navstik internal definitions
+ */
+
+#pragma once
+
+/****************************************************************************************************
+ * Included Files
+ ****************************************************************************************************/
+
+#include <nuttx/config.h>
+#include <nuttx/compiler.h>
+#include <stdint.h>
+
+__BEGIN_DECLS
+
+/* these headers are not C++ safe */
+#include <stm32.h>
+
+ 
+/****************************************************************************************************
+ * Definitions
+ ****************************************************************************************************/
+/* Configuration ************************************************************************************/
+
+/* Navstik GPIOs ***********************************************************************************/
+/* LEDs */
+
+#define GPIO_LED1		(GPIO_OUTPUT|GPIO_PUSHPULL|GPIO_SPEED_50MHz|GPIO_OUTPUT_CLEAR|GPIO_PORTC|GPIO_PIN4)
+#define GPIO_LED2		(GPIO_OUTPUT|GPIO_PUSHPULL|GPIO_SPEED_50MHz|GPIO_OUTPUT_CLEAR|GPIO_PORTC|GPIO_PIN5)
+
+/* Power Enable GPIOs */
+#define GPIO_SENSOR_PWR_EN		(GPIO_OUTPUT|GPIO_PUSHPULL|GPIO_SPEED_50MHz|GPIO_OUTPUT_CLEAR|GPIO_PORTC|GPIO_PIN15)
+
+#define GPIO_GPS_PWR_EN		(GPIO_OUTPUT|GPIO_PUSHPULL|GPIO_SPEED_50MHz|GPIO_OUTPUT_CLEAR|GPIO_PORTA|GPIO_PIN4)
+
+#define GPIO_TELE_PWR_EN		(GPIO_OUTPUT|GPIO_PUSHPULL|GPIO_SPEED_50MHz|GPIO_OUTPUT_CLEAR|GPIO_PORTC|GPIO_PIN10)
+
+/* External interrupts */
+#define GPIO_EXTI_COMPASS	(GPIO_INPUT|GPIO_FLOAT|GPIO_EXTI|GPIO_PORTC|GPIO_PIN14)
+
+/* SPI chip selects */
+#define GPIO_SPI_CS_FLASH	(GPIO_OUTPUT|GPIO_PUSHPULL|GPIO_SPEED_50MHz|GPIO_OUTPUT_SET|GPIO_PORTA|GPIO_PIN5)
+#define GPIO_SPI_CS_SDCARD	(GPIO_OUTPUT|GPIO_PUSHPULL|GPIO_SPEED_50MHz|GPIO_OUTPUT_SET|GPIO_PORTA|GPIO_PIN0)
+
+#if 0
+/* User GPIOs
+ *
+ * GPIO0-1 are the buffered high-power GPIOs.
+ * GPIO2-5 are the USART2 pins.
+ * GPIO6-7 are the CAN2 pins.
+ */
+//#define GPIO_GPIO0_INPUT	(GPIO_INPUT|GPIO_PULLUP|GPIO_PORTC|GPIO_PIN4)
+//#define GPIO_GPIO1_INPUT	(GPIO_INPUT|GPIO_PULLUP|GPIO_PORTC|GPIO_PIN5)
+//#define GPIO_GPIO2_INPUT	(GPIO_INPUT|GPIO_PULLUP|GPIO_PORTA|GPIO_PIN0)
+//#define GPIO_GPIO3_INPUT	(GPIO_INPUT|GPIO_PULLUP|GPIO_PORTA|GPIO_PIN1)
+//#define GPIO_GPIO4_INPUT	(GPIO_INPUT|GPIO_PULLUP|GPIO_PORTA|GPIO_PIN2)
+//#define GPIO_GPIO5_INPUT	(GPIO_INPUT|GPIO_PULLUP|GPIO_PORTA|GPIO_PIN3)
+//#define GPIO_GPIO6_INPUT	(GPIO_INPUT|GPIO_PULLUP|GPIO_PORTB|GPIO_PIN13)
+//#define GPIO_GPIO7_INPUT	(GPIO_INPUT|GPIO_PULLUP|GPIO_PORTB|GPIO_PIN2)
+
+//#define GPIO_GPIO0_OUTPUT	(GPIO_OUTPUT|GPIO_PUSHPULL|GPIO_SPEED_2MHz|GPIO_OUTPUT_CLEAR|GPIO_PORTC|GPIO_PIN4)
+//#define GPIO_GPIO1_OUTPUT	(GPIO_OUTPUT|GPIO_PUSHPULL|GPIO_SPEED_2MHz|GPIO_OUTPUT_CLEAR|GPIO_PORTC|GPIO_PIN5)
+//#define GPIO_GPIO2_OUTPUT	(GPIO_OUTPUT|GPIO_PUSHPULL|GPIO_SPEED_2MHz|GPIO_OUTPUT_CLEAR|GPIO_PORTA|GPIO_PIN0)
+//#define GPIO_GPIO3_OUTPUT	(GPIO_OUTPUT|GPIO_PUSHPULL|GPIO_SPEED_2MHz|GPIO_OUTPUT_CLEAR|GPIO_PORTA|GPIO_PIN1)
+//#define GPIO_GPIO4_OUTPUT	(GPIO_OUTPUT|GPIO_PUSHPULL|GPIO_SPEED_2MHz|GPIO_OUTPUT_CLEAR|GPIO_PORTA|GPIO_PIN2)
+//#define GPIO_GPIO5_OUTPUT	(GPIO_OUTPUT|GPIO_PUSHPULL|GPIO_SPEED_2MHz|GPIO_OUTPUT_CLEAR|GPIO_PORTA|GPIO_PIN3)
+//#define GPIO_GPIO6_OUTPUT	(GPIO_OUTPUT|GPIO_PUSHPULL|GPIO_SPEED_2MHz|GPIO_OUTPUT_CLEAR|GPIO_PORTB|GPIO_PIN13)
+//#define GPIO_GPIO7_OUTPUT	(GPIO_OUTPUT|GPIO_PUSHPULL|GPIO_SPEED_2MHz|GPIO_OUTPUT_CLEAR|GPIO_PORTB|GPIO_PIN12)
+//#define GPIO_GPIO_DIR		(GPIO_OUTPUT|GPIO_PUSHPULL|GPIO_SPEED_2MHz|GPIO_OUTPUT_CLEAR|GPIO_PORTC|GPIO_PIN13)
+#endif
+
+/* USB OTG FS
+ *
+ * PA9  OTG_FS_VBUS VBUS sensing
+ */
+#define GPIO_OTGFS_VBUS (GPIO_INPUT|GPIO_FLOAT|GPIO_SPEED_100MHz|GPIO_OPENDRAIN|GPIO_PORTA|GPIO_PIN9)
+
+/****************************************************************************************************
+ * Public Types
+ ****************************************************************************************************/
+
+/****************************************************************************************************
+ * Public data
+ ****************************************************************************************************/
+
+#ifndef __ASSEMBLY__
+
+/****************************************************************************************************
+ * Public Functions
+ ****************************************************************************************************/
+
+/****************************************************************************************************
+ * Name: stm32_spiinitialize
+ *
+ * Description:
+ *   Called to configure SPI chip select GPIO pins for the Navstik board.
+ *
+ ****************************************************************************************************/
+
+extern void stm32_spiinitialize(void);
+
+#endif /* __ASSEMBLY__ */
+
+__END_DECLS
diff --git a/src/drivers/boards/navstik/navstik_led.c b/src/drivers/boards/navstik/navstik_led.c
new file mode 100644
index 0000000..04cbaeb
--- /dev/null
+++ b/src/drivers/boards/navstik/navstik_led.c
@@ -0,0 +1,89 @@
+/****************************************************************************
+ *
+ *   Copyright (C) 2013 Navstik Development Team. All rights reserved.
+ *   Copyright (C) 2012 PX4 Development Team. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name PX4 nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/**
+ * @file navstik_led.c
+ *
+ * Navstik LED backend.
+ */
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <debug.h>
+
+#include <arch/board/board.h>
+
+#include "chip.h"
+#include "up_arch.h"
+#include "up_internal.h"
+#include "stm32.h"
+#include "navstik_internal.h"
+
+__EXPORT void led_init()
+{
+	/* Configure LED1-2 GPIOs for output */
+
+	stm32_configgpio(GPIO_LED1);
+	stm32_configgpio(GPIO_LED2);
+}
+
+__EXPORT void led_on(int led)
+{
+	if (led == 0)
+	{
+		/* Pull up to switch on */
+		stm32_gpiowrite(GPIO_LED1, true);
+	}
+	if (led == 1)
+	{
+		/* Pull up to switch on */
+		stm32_gpiowrite(GPIO_LED2, true);
+	}
+}
+
+__EXPORT void led_off(int led)
+{
+	if (led == 0)
+	{
+		/* Pull down to switch off */
+		stm32_gpiowrite(GPIO_LED1, false);
+	}
+	if (led == 1)
+	{
+		/* Pull down to switch off */
+		stm32_gpiowrite(GPIO_LED2, false);
+	}
+}
diff --git a/src/drivers/boards/navstik/navstik_pwm_servo.c b/src/drivers/boards/navstik/navstik_pwm_servo.c
new file mode 100644
index 0000000..6199c68
--- /dev/null
+++ b/src/drivers/boards/navstik/navstik_pwm_servo.c
@@ -0,0 +1,131 @@
+/****************************************************************************
+ *
+ *   Copyright (C) 2012 PX4 Development Team. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name PX4 nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/*
+ * @file navstik_pwm_servo.c
+ *
+ * Configuration data for the stm32 pwm_servo driver.
+ *
+ * Note that these arrays must always be fully-sized.
+ */
+
+#include <stdint.h>
+
+#include <drivers/stm32/drv_pwm_servo.h>
+
+#include <arch/board/board.h>
+#include <drivers/drv_pwm_output.h>
+
+#include <stm32.h>
+#include <stm32_gpio.h>
+#include <stm32_tim.h>
+
+/* PWM
+ *
+ * The Navstik has six PWM outputs
+ * The mapping are as follows :
+ * PB5	Servo 1 Timer 3 Channel 2 (AF2)
+ * PA10	Servo 2 Timer 1 channel 3 (AF1)
+ * PC8	Servo 3 Timer 8 Channel 3 (AF3)
+ * PB11	Servo 4 Timer 2 Channel 4 (AF1)
+ * PB1	Servo 5 Timer 3 Channel 4 (AF2)
+ * PB0	Servo 6 Timer 3 Channel 3 (AF2)
+ *
+ */
+
+
+__EXPORT const struct pwm_servo_timer pwm_timers[PWM_SERVO_MAX_TIMERS] = {
+	{	/* Timer 1 */
+		.base = STM32_TIM1_BASE,
+		.clock_register = STM32_RCC_APB2ENR,
+		.clock_bit = RCC_APB2ENR_TIM1EN,
+		.clock_freq = STM32_APB2_TIM1_CLKIN
+	},
+	{	/* Timer 2 */
+		.base = STM32_TIM2_BASE,
+		.clock_register = STM32_RCC_APB1ENR,
+		.clock_bit = RCC_APB1ENR_TIM2EN,
+		.clock_freq = STM32_APB1_TIM2_CLKIN
+	},
+	{	/* Timer 3 */
+		.base = STM32_TIM3_BASE,
+		.clock_register = STM32_RCC_APB1ENR,
+		.clock_bit = RCC_APB1ENR_TIM3EN,
+		.clock_freq = STM32_APB1_TIM3_CLKIN
+	},
+	{	/* Timer 8 */
+		.base = STM32_TIM8_BASE,
+		.clock_register = STM32_RCC_APB2ENR,
+		.clock_bit = RCC_APB2ENR_TIM8EN,
+		.clock_freq = STM32_APB2_TIM8_CLKIN
+	}
+};
+
+__EXPORT const struct pwm_servo_channel pwm_channels[PWM_SERVO_MAX_CHANNELS] = {
+	{
+		.gpio = GPIO_TIM3_CH2OUT,
+		.timer_index = 2,
+		.timer_channel = 2,
+		.default_value = 1000,
+	},
+	{
+		.gpio = GPIO_TIM1_CH3OUT,
+		.timer_index = 0,
+		.timer_channel = 3,
+		.default_value = 1000,
+	},
+	{
+		.gpio = GPIO_TIM8_CH3OUT,
+		.timer_index = 3,
+		.timer_channel = 3,
+		.default_value = 1000,
+	},
+	{
+		.gpio = GPIO_TIM2_CH4OUT,
+		.timer_index = 1,
+		.timer_channel = 4,
+		.default_value = 1000,
+	},
+	{
+		.gpio = GPIO_TIM3_CH4OUT,
+		.timer_index = 2,
+		.timer_channel = 4,
+		.default_value = 1000,
+	},
+	{
+		.gpio = GPIO_TIM3_CH3OUT,
+		.timer_index = 2,
+		.timer_channel = 3,
+		.default_value = 1000,
+	}
+};
diff --git a/src/drivers/boards/navstik/navstik_spi.c b/src/drivers/boards/navstik/navstik_spi.c
new file mode 100644
index 0000000..dc2ad6c
--- /dev/null
+++ b/src/drivers/boards/navstik/navstik_spi.c
@@ -0,0 +1,126 @@
+/****************************************************************************
+ *
+ *   Copyright (C) 2013 Navstik Development Team. Based on PX4 port.
+ *
+ *   Copyright (C) 2012 PX4 Development Team. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name PX4 nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/**
+ * @file navstik_spi.c
+ *
+ * Board-specific SPI functions.
+ */
+
+/************************************************************************************
+ * Included Files
+ ************************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <debug.h>
+
+#include <nuttx/spi.h>
+#include <arch/board/board.h>
+
+#include "up_arch.h"
+#include "chip.h"
+#include "stm32.h"
+#include "navstik_internal.h"
+
+/************************************************************************************
+ * Public Functions
+ ************************************************************************************/
+
+/************************************************************************************
+ * Name: stm32_spiinitialize
+ *
+ * Description:
+ *   Called to configure SPI chip select GPIO pins for the Navstik board.
+ *
+ ************************************************************************************/
+
+__EXPORT void weak_function stm32_spiinitialize(void)
+{
+	stm32_configgpio(GPIO_SPI_CS_FLASH);
+	stm32_configgpio(GPIO_SPI_CS_SDCARD);
+
+	/* De-activate all peripherals,
+	 * required for some peripheral
+	 * state machines
+	 */
+	stm32_gpiowrite(GPIO_SPI_CS_FLASH, 1);
+	stm32_gpiowrite(GPIO_SPI_CS_SDCARD, 1);
+}
+
+__EXPORT void stm32_spi2select(FAR struct spi_dev_s *dev, enum spi_dev_e devid, bool selected)
+{
+
+	/* SPI select is active low, so write !selected to select the device */
+/*	switch (devid) {
+	case NAVSTIK_SPIDEV_FLASH:
+		// Making sure the other peripherals are not selected
+		stm32_gpiowrite(GPIO_SPI_CS_FLASH, !selected);
+		stm32_gpiowrite(GPIO_SPI_CS_SDCARD, selected);
+		break;
+
+	case NAVSTIK_SPIDEV_SDCARD:
+		// Making sure the other peripherals are not selected
+		stm32_gpiowrite(GPIO_SPI_CS_SDCARD, !selected);
+		stm32_gpiowrite(GPIO_SPI_CS_FLASH, selected);
+		break;
+
+	default:
+		break;
+
+	}
+*/
+
+		stm32_gpiowrite(GPIO_SPI_CS_SDCARD, !selected);
+
+}
+
+__EXPORT uint8_t stm32_spi1status(FAR struct spi_dev_s *dev, enum spi_dev_e devid)
+{
+	return !SPI_STATUS_PRESENT;
+}
+
+__EXPORT uint8_t stm32_spi2status(FAR struct spi_dev_s *dev, enum spi_dev_e devid)
+{
+	return SPI_STATUS_PRESENT;
+}
+
+__EXPORT uint8_t stm32_spi3status(FAR struct spi_dev_s *dev, enum spi_dev_e devid)
+{
+	return !SPI_STATUS_PRESENT;
+}
+
diff --git a/src/drivers/boards/navstik/navstik_usb.c b/src/drivers/boards/navstik/navstik_usb.c
new file mode 100644
index 0000000..9f6421a
--- /dev/null
+++ b/src/drivers/boards/navstik/navstik_usb.c
@@ -0,0 +1,108 @@
+/****************************************************************************
+ *
+ *   Copyright (C) 2012 PX4 Development Team. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name PX4 nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/**
+ * @file navstik_usb.c
+ *
+ * Board-specific USB functions.
+ */
+
+/************************************************************************************
+ * Included Files
+ ************************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <sys/types.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <debug.h>
+
+#include <nuttx/usb/usbdev.h>
+#include <nuttx/usb/usbdev_trace.h>
+
+#include "up_arch.h"
+#include "stm32.h"
+#include "navstik_internal.h"
+
+/************************************************************************************
+ * Definitions
+ ************************************************************************************/
+
+/************************************************************************************
+ * Private Functions
+ ************************************************************************************/
+
+/************************************************************************************
+ * Public Functions
+ ************************************************************************************/
+
+/************************************************************************************
+ * Name: stm32_usbinitialize
+ *
+ * Description:
+ *   Called to setup USB-related GPIO pins for the Navstik board.
+ *
+ ************************************************************************************/
+
+__EXPORT void stm32_usbinitialize(void)
+{
+	/* The OTG FS has an internal soft pull-up */
+
+	/* Configure the OTG FS VBUS sensing GPIO, Power On, and Overcurrent GPIOs */
+
+#ifdef CONFIG_STM32_OTGFS
+	stm32_configgpio(GPIO_OTGFS_VBUS);
+	/* XXX We only support device mode
+	stm32_configgpio(GPIO_OTGFS_PWRON);
+	stm32_configgpio(GPIO_OTGFS_OVER);
+	*/
+#endif
+}
+
+/************************************************************************************
+ * Name:  stm32_usbsuspend
+ *
+ * Description:
+ *   Board logic must provide the stm32_usbsuspend logic if the USBDEV driver is
+ *   used.  This function is called whenever the USB enters or leaves suspend mode.
+ *   This is an opportunity for the board logic to shutdown clocks, power, etc.
+ *   while the USB is suspended.
+ *
+ ************************************************************************************/
+
+__EXPORT void stm32_usbsuspend(FAR struct usbdev_s *dev, bool resume)
+{
+	ulldbg("resume: %d\n", resume);
+}
+
diff --git a/src/drivers/drv_gpio.h b/src/drivers/drv_gpio.h
index 510983d..931929b 100644
--- a/src/drivers/drv_gpio.h
+++ b/src/drivers/drv_gpio.h
@@ -58,6 +58,8 @@
 # define GPIO_CAN_TX		(1<<6)		/**< CAN2 TX */
 # define GPIO_CAN_RX		(1<<7)		/**< CAN2 RX */
 
+#endif
+
 /**
  * Default GPIO device - other devices may also support this protocol if
  * they also export GPIO-like things.  This is always the GPIOs on the
@@ -66,12 +68,35 @@
 # define PX4FMU_DEVICE_PATH	"/dev/px4fmu"
 # define PX4IO_DEVICE_PATH	"/dev/px4io"
 
-#endif
-
 #ifndef PX4IO_DEVICE_PATH
 #  error No GPIO support for this board.
 #endif
 
+#ifdef CONFIG_ARCH_BOARD_NAVSTIK
+/*
+ * NAVSTIK GPIO numbers.
+ *
+ * For shared pins, alternate function 1 selects the non-GPIO mode 
+ * (USART2, CAN2, etc.)
+ */
+# define GPIO_EXT_1             (1<<0)          /**< high-power GPIO 1 */
+# define GPIO_EXT_2             (1<<1)          /**< high-power GPIO 1 */
+# define GPIO_MULTI_1           (1<<2)          /**< USART2 CTS */
+# define GPIO_MULTI_2           (1<<3)          /**< USART2 RTS */
+# define GPIO_MULTI_3           (1<<4)          /**< USART2 TX */
+# define GPIO_MULTI_4           (1<<5)          /**< USART2 RX */
+//# define GPIO_CAN_TX            (1<<6)          /**< CAN2 TX */
+//# define GPIO_CAN_RX            (1<<7)          /**< CAN2 RX */
+
+/**
+ * Default GPIO device - other devices may also support this protocol if
+ * they also export GPIO-like things.  This is always the GPIOs on the
+ * main board.
+ */
+# define NAVSTIK_DEVICE_PATH       "/dev/navstik"
+
+#endif
+
 /*
  * IOCTL definitions.
  *
@@ -114,4 +139,4 @@
 /** read all the GPIOs and return their values in *(uint32_t *)arg */
 #define GPIO_GET	GPIOC(12)
 
-#endif /* _DRV_GPIO_H */
\ No newline at end of file
+#endif /* _DRV_GPIO_H */
diff --git a/src/drivers/hmc5883/hmc5883.cpp b/src/drivers/hmc5883/hmc5883.cpp
index ac3bdc1..249436a 100644
--- a/src/drivers/hmc5883/hmc5883.cpp
+++ b/src/drivers/hmc5883/hmc5883.cpp
@@ -74,8 +74,15 @@
 /*
  * HMC5883 internal constants and data structures.
  */
-
+#ifdef CONFIG_ARCH_BOARD_PX4FMU_V1 || CONFIG_ARCH_BOARD_PX4IO
+#define HMC5883L_BUS			PX4_I2C_BUS_EXPANSION
 #define HMC5883L_ADDRESS		PX4_I2C_OBDEV_HMC5883
+#endif
+
+#ifdef CONFIG_ARCH_BOARD_NAVSTIK
+#define HMC5883L_BUS			NAVSTIK_I2C_BUS_SENSORS
+#define HMC5883L_ADDRESS		NAVSTIK_I2C_OBDEV_HMC5883
+#endif
 
 /* Max measurement rate is 160Hz */
 #define HMC5883_CONVERSION_INTERVAL	(1000000 / 160)	/* microseconds */
@@ -1225,7 +1232,7 @@ start()
 		errx(0, "already started");
 
 	/* create the driver, attempt expansion bus first */
-	g_dev = new HMC5883(PX4_I2C_BUS_EXPANSION);
+	g_dev = new HMC5883(HMC5883L_BUS);
 	if (g_dev != nullptr && OK != g_dev->init()) {
 		delete g_dev;
 		g_dev = nullptr;
diff --git a/src/drivers/mpu60x0/module.mk b/src/drivers/mpu60x0/module.mk
new file mode 100644
index 0000000..8583463
--- /dev/null
+++ b/src/drivers/mpu60x0/module.mk
@@ -0,0 +1,44 @@
+############################################################################
+#
+#   Copyright (c) 2013 Navstik Development Team. All rights reserved.
+#   Copyright (c) 2012, 2013 PX4 Development Team. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name PX4 nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+#
+# Makefile to build the MPU60x0 driver.
+#
+
+MODULE_COMMAND	= mpu60x0
+
+# XXX seems excessive, check if 2048 is not sufficient
+MODULE_STACKSIZE	= 4096
+
+SRCS		= mpu60x0.cpp
diff --git a/src/drivers/mpu60x0/mpu60x0.cpp b/src/drivers/mpu60x0/mpu60x0.cpp
new file mode 100644
index 0000000..7d6c704
--- /dev/null
+++ b/src/drivers/mpu60x0/mpu60x0.cpp
@@ -0,0 +1,1197 @@
+/****************************************************************************
+ *
+ *   Copyright (C) 2013 Navstik Development Team. All rights reserved. Based on PX4 port.
+ *
+ *   Copyright (C) 2012 PX4 Development Team. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name PX4 nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/**
+ * @file mpu60x0.cpp
+ *
+ * Driver for the Invensense MPU60x0 connected via I2C.
+ */
+
+#include <nuttx/config.h>
+
+#include <drivers/device/i2c.h>
+
+#include <sys/types.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <semaphore.h>
+#include <string.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <errno.h>
+#include <stdio.h>
+#include <math.h>
+#include <unistd.h>
+
+#include <systemlib/perf_counter.h>
+#include <systemlib/err.h>
+#include <systemlib/conversions.h>
+
+#include <nuttx/arch.h>
+#include <nuttx/clock.h>
+
+#include <arch/board/board.h>
+#include <drivers/drv_hrt.h>
+
+//#include <drivers/device/spi.h>
+#include <drivers/drv_accel.h>
+#include <drivers/drv_gyro.h>
+
+#define MPU60x0_BUS			NAVSTIK_I2C_BUS_MPU
+#define MPU60x0_ADDRESS		NAVSTIK_I2C_OBDEV_MPU60x0
+
+#define DIR_READ			0x80
+#define DIR_WRITE			0x00
+
+// MPU 6000 registers
+#define MPUREG_WHOAMI			0x75
+#define MPUREG_SMPLRT_DIV		0x19
+#define MPUREG_CONFIG			0x1A
+#define MPUREG_GYRO_CONFIG		0x1B
+#define MPUREG_ACCEL_CONFIG		0x1C
+#define MPUREG_FIFO_EN			0x23
+#define MPUREG_INT_PIN_CFG		0x37
+#define MPUREG_INT_ENABLE		0x38
+#define MPUREG_INT_STATUS		0x3A
+#define MPUREG_ACCEL_XOUT_H		0x3B
+#define MPUREG_ACCEL_XOUT_L		0x3C
+#define MPUREG_ACCEL_YOUT_H		0x3D
+#define MPUREG_ACCEL_YOUT_L		0x3E
+#define MPUREG_ACCEL_ZOUT_H		0x3F
+#define MPUREG_ACCEL_ZOUT_L		0x40
+#define MPUREG_TEMP_OUT_H		0x41
+#define MPUREG_TEMP_OUT_L		0x42
+#define MPUREG_GYRO_XOUT_H		0x43
+#define MPUREG_GYRO_XOUT_L		0x44
+#define MPUREG_GYRO_YOUT_H		0x45
+#define MPUREG_GYRO_YOUT_L		0x46
+#define MPUREG_GYRO_ZOUT_H		0x47
+#define MPUREG_GYRO_ZOUT_L		0x48
+#define MPUREG_USER_CTRL		0x6A
+#define MPUREG_PWR_MGMT_1		0x6B
+#define MPUREG_PWR_MGMT_2		0x6C
+#define MPUREG_FIFO_COUNTH		0x72
+#define MPUREG_FIFO_COUNTL		0x73
+#define MPUREG_FIFO_R_W			0x74
+#define MPUREG_PRODUCT_ID		0x0C
+
+// Configuration bits MPU 3000 and MPU 6000 (not revised)?
+#define BIT_SLEEP			0x40
+#define BIT_H_RESET			0x80
+#define BITS_CLKSEL			0x07
+#define MPU_CLK_SEL_PLLGYROX		0x01
+#define MPU_CLK_SEL_PLLGYROZ		0x03
+#define MPU_EXT_SYNC_GYROX		0x02
+#define BITS_FS_250DPS			0x00
+#define BITS_FS_500DPS			0x08
+#define BITS_FS_1000DPS			0x10
+#define BITS_FS_2000DPS			0x18
+#define BITS_FS_MASK			0x18
+#define BITS_DLPF_CFG_256HZ_NOLPF2	0x00
+#define BITS_DLPF_CFG_188HZ		0x01
+#define BITS_DLPF_CFG_98HZ		0x02
+#define BITS_DLPF_CFG_42HZ		0x03
+#define BITS_DLPF_CFG_20HZ		0x04
+#define BITS_DLPF_CFG_10HZ		0x05
+#define BITS_DLPF_CFG_5HZ		0x06
+#define BITS_DLPF_CFG_2100HZ_NOLPF	0x07
+#define BITS_DLPF_CFG_MASK		0x07
+#define BIT_INT_ANYRD_2CLEAR		0x10
+#define BIT_RAW_RDY_EN			0x01
+#define BIT_I2C_IF_DIS			0x10
+#define BIT_INT_STATUS_DATA		0x01
+
+// Product ID Description for MPU6000
+// high 4 bits 	low 4 bits
+// Product Name	Product Revision
+#define MPU6000ES_REV_C4		0x14
+#define MPU6000ES_REV_C5		0x15
+#define MPU6000ES_REV_D6		0x16
+#define MPU6000ES_REV_D7		0x17
+#define MPU6000ES_REV_D8		0x18
+#define MPU6000_REV_C4			0x54
+#define MPU6000_REV_C5			0x55
+#define MPU6000_REV_D6			0x56
+#define MPU6000_REV_D7			0x57
+#define MPU6000_REV_D8			0x58
+#define MPU6000_REV_D9			0x59
+#define MPU6000_REV_D10			0x5A
+
+
+class MPU60x0_gyro;
+
+class MPU60x0 : public device::I2C
+{
+public:
+	MPU60x0(int bus);
+	~MPU60x0();
+
+	virtual int		init();
+
+	virtual ssize_t		read(struct file *filp, char *buffer, size_t buflen);
+	virtual int		ioctl(struct file *filp, int cmd, unsigned long arg);
+
+	/**
+	 * Diagnostics - print some basic information about the driver.
+	 */
+	void			print_info();
+
+protected:
+	virtual int		probe();
+
+	friend class MPU60x0_gyro;
+
+	virtual ssize_t		gyro_read(struct file *filp, char *buffer, size_t buflen);
+	virtual int		gyro_ioctl(struct file *filp, int cmd, unsigned long arg);
+
+private:
+	MPU60x0_gyro		*_gyro;
+	uint8_t			_product;	/** product code */
+
+	struct hrt_call		_call;
+	unsigned		_call_interval;
+
+	struct accel_report	_accel_report;
+	struct accel_scale	_accel_scale;
+	float			_accel_range_scale;
+	float			_accel_range_m_s2;
+	orb_advert_t		_accel_topic;
+
+	struct gyro_report	_gyro_report;
+	struct gyro_scale	_gyro_scale;
+	float			_gyro_range_scale;
+	float			_gyro_range_rad_s;
+	orb_advert_t		_gyro_topic;
+
+	unsigned		_reads;
+	perf_counter_t		_sample_perf;
+
+	/**
+	 * Start automatic measurement.
+	 */
+	void			start();
+
+	/**
+	 * Stop automatic measurement.
+	 */
+	void			stop();
+
+	/**
+	 * Static trampoline from the hrt_call context; because we don't have a
+	 * generic hrt wrapper yet.
+	 *
+	 * Called by the HRT in interrupt context at the specified rate if
+	 * automatic polling is enabled.
+	 *
+	 * @param arg		Instance pointer for the driver that is polling.
+	 */
+	static void		measure_trampoline(void *arg);
+
+	/**
+	 * Fetch measurements from the sensor and update the report ring.
+	 */
+	void			measure();
+
+	/**
+	 * Read a register from the MPU60x0
+	 *
+	 * @param		The register to read.
+	 * @return		The value that was read.
+	 */
+	uint8_t			read_reg(uint8_t reg);
+//	uint16_t		read_reg16(unsigned reg);
+
+	/**
+	 * Write a register in the MPU60x0
+	 *
+	 * @param reg		The register to write.
+	 * @param value		The new value to write.
+	 */
+	void			write_reg(uint8_t reg, uint8_t value);
+
+	/**
+	 * Modify a register in the MPU60x0
+	 *
+	 * Bits are cleared before bits are set.
+	 *
+	 * @param reg		The register to modify.
+	 * @param clearbits	Bits in the register to clear.
+	 * @param setbits	Bits in the register to set.
+	 */
+	void			modify_reg(uint8_t reg, uint8_t clearbits, uint8_t setbits);
+
+	/**
+	 * Set the MPU60x0 measurement range.
+	 *
+	 * @param max_g		The maximum G value the range must support.
+	 * @return		OK if the value can be supported, -ERANGE otherwise.
+	 */
+	int			set_range(unsigned max_g);
+
+	/**
+	 * Swap a 16-bit value read from the MPU60x0 to native byte order.
+	 */
+	uint16_t		swap16(uint16_t val) { return (val >> 8) | (val << 8);	}
+
+	/**
+	 * Self test
+	 *
+	 * @return 0 on success, 1 on failure
+	 */
+	 int 			self_test();
+
+};
+
+/**
+ * Helper class implementing the gyro driver node.
+ */
+class MPU60x0_gyro : public device::CDev
+{
+public:
+	MPU60x0_gyro(MPU60x0 *parent);
+	~MPU60x0_gyro();
+
+	virtual ssize_t		read(struct file *filp, char *buffer, size_t buflen);
+	virtual int		ioctl(struct file *filp, int cmd, unsigned long arg);
+
+protected:
+	friend class MPU60x0;
+
+	void			parent_poll_notify();
+private:
+	MPU60x0			*_parent;
+};
+
+/** driver 'main' command */
+extern "C" { __EXPORT int mpu60x0_main(int argc, char *argv[]); }
+
+MPU60x0::MPU60x0(int bus) :
+	I2C("MPU60x0", ACCEL_DEVICE_PATH, bus, MPU60x0_ADDRESS, 400000),
+	_gyro(new MPU60x0_gyro(this)),
+	_product(0),
+	_call_interval(0),
+	_accel_range_scale(0.0f),
+	_accel_range_m_s2(0.0f),
+	_accel_topic(-1),
+	_gyro_range_scale(0.0f),
+	_gyro_range_rad_s(0.0f),
+	_gyro_topic(-1),
+	_reads(0),
+	_sample_perf(perf_alloc(PC_ELAPSED, "mpu60x0_read"))
+{
+	// disable debug() calls
+	_debug_enabled = false;
+
+	// default accel scale factors
+	_accel_scale.x_offset = 0;
+	_accel_scale.x_scale  = 1.0f;
+	_accel_scale.y_offset = 0;
+	_accel_scale.y_scale  = 1.0f;
+	_accel_scale.z_offset = 0;
+	_accel_scale.z_scale  = 1.0f;
+
+	// default gyro scale factors
+	_gyro_scale.x_offset = 0;
+	_gyro_scale.x_scale  = 1.0f;
+	_gyro_scale.y_offset = 0;
+	_gyro_scale.y_scale  = 1.0f;
+	_gyro_scale.z_offset = 0;
+	_gyro_scale.z_scale  = 1.0f;
+
+	memset(&_accel_report, 0, sizeof(_accel_report));
+	memset(&_gyro_report, 0, sizeof(_gyro_report));
+	memset(&_call, 0, sizeof(_call));
+}
+
+MPU60x0::~MPU60x0()
+{
+	/* make sure we are truly inactive */
+	stop();
+
+	/* delete the gyro subdriver */
+	delete _gyro;
+
+	/* delete the perf counter */
+	perf_free(_sample_perf);
+}
+
+int
+MPU60x0::init()
+{
+	int ret;
+
+	/* do I2C init (and probe) first */
+	ret = I2C::init();
+
+	/* if probe/setup failed, bail now */
+	if (ret != OK) {
+		debug("I2C setup failed");
+		return ret;
+	}
+
+	/* advertise sensor topics */
+	_accel_topic = orb_advertise(ORB_ID(sensor_accel), &_accel_report);
+	_gyro_topic = orb_advertise(ORB_ID(sensor_gyro), &_gyro_report);
+
+	// Chip reset
+	write_reg(MPUREG_PWR_MGMT_1, BIT_H_RESET);
+	up_udelay(10000);
+
+	// Wake up device and select GyroZ clock (better performance)
+	write_reg(MPUREG_PWR_MGMT_1, MPU_CLK_SEL_PLLGYROZ);
+	up_udelay(1000);
+
+	// Disable I2C bus (recommended on datasheet)
+	//write_reg(MPUREG_USER_CTRL, BIT_I2C_IF_DIS);
+	//up_udelay(1000);
+
+	// DLPF = 20Hz (low pass filter), Gyro output rate = 1kHz
+	write_reg(MPUREG_CONFIG, BITS_DLPF_CFG_20HZ);
+	usleep(1000);
+	// Gyro scale 2000 deg/s ()
+	write_reg(MPUREG_GYRO_CONFIG, BITS_FS_2000DPS);
+	usleep(1000);
+
+	// SAMPLE RATE
+	write_reg(MPUREG_SMPLRT_DIV, 0x04); // Sample rate = Gyro output rate / (1 + divider) = 1Khz/(4+1) = 200Hz
+	usleep(1000);
+
+	// correct gyro scale factors
+	// scale to rad/s in SI units
+	// 2000 deg/s = (2000/180)*PI = 34.906585 rad/s
+	// scaling factor:
+	// 1/(2^15)*(2000/180)*PI
+	_gyro_scale.x_offset = 0;
+	_gyro_scale.x_scale  = 1.0f;
+	_gyro_scale.y_offset = 0;
+	_gyro_scale.y_scale  = 1.0f;
+	_gyro_scale.z_offset = 0;
+	_gyro_scale.z_scale  = 1.0f;
+	_gyro_range_scale = (0.0174532 / 16.4);//1.0f / (32768.0f * (2000.0f / 180.0f) * M_PI_F);
+	_gyro_range_rad_s = (2000.0f / 180.0f) * M_PI_F;
+
+	// product-specific scaling
+	switch (_product) {
+	case MPU6000ES_REV_C4:
+	case MPU6000ES_REV_C5:
+	case MPU6000_REV_C4:
+	case MPU6000_REV_C5:
+		// Accel scale 8g (4096 LSB/g)
+		// Rev C has different scaling than rev D
+		write_reg(MPUREG_ACCEL_CONFIG, 1 << 3);
+		break;
+
+	case MPU6000ES_REV_D6:
+	case MPU6000ES_REV_D7:
+	case MPU6000ES_REV_D8:
+	case MPU6000_REV_D6:
+	case MPU6000_REV_D7:
+	case MPU6000_REV_D8:
+	case MPU6000_REV_D9:
+	case MPU6000_REV_D10:
+		// Accel scale 8g (4096 LSB/g)
+		write_reg(MPUREG_ACCEL_CONFIG, 2 << 3);
+		break;
+	}
+
+	// Correct accel scale factors of 4096 LSB/g
+	// scale to m/s^2 ( 1g = 9.81 m/s^2)
+	_accel_scale.x_offset = 0;
+	_accel_scale.x_scale  = 1.0f;
+	_accel_scale.y_offset = 0;
+	_accel_scale.y_scale  = 1.0f;
+	_accel_scale.z_offset = 0;
+	_accel_scale.z_scale  = 1.0f;
+	_accel_range_scale = (9.81f / 4096.0f);
+	_accel_range_m_s2 = 8.0f * 9.81f;
+
+	usleep(1000);
+
+	// INT CFG => Interrupt on Data Ready
+	write_reg(MPUREG_INT_ENABLE, BIT_RAW_RDY_EN);        // INT: Raw data ready
+	usleep(1000);
+	write_reg(MPUREG_INT_PIN_CFG, BIT_INT_ANYRD_2CLEAR); // INT: Clear on any read
+	usleep(1000);
+
+	// Oscillator set
+	// write_reg(MPUREG_PWR_MGMT_1,MPU_CLK_SEL_PLLGYROZ);
+	usleep(1000);
+
+	/* do CDev init for the gyro device node, keep it optional */
+	int gyro_ret = _gyro->init();
+
+	if (gyro_ret != OK) {
+		_gyro_topic = -1;
+		debug("Gyro init failed");
+	}
+
+	return ret;
+}
+
+int
+MPU60x0::probe()
+{
+
+	/* look for a product ID we recognise */
+	_product = read_reg(MPUREG_PRODUCT_ID);
+
+	// verify product revision
+	switch (_product) {
+	case MPU6000ES_REV_C4:
+	case MPU6000ES_REV_C5:
+	case MPU6000_REV_C4:
+	case MPU6000_REV_C5:
+	case MPU6000ES_REV_D6:
+	case MPU6000ES_REV_D7:
+	case MPU6000ES_REV_D8:
+	case MPU6000_REV_D6:
+	case MPU6000_REV_D7:
+	case MPU6000_REV_D8:
+	case MPU6000_REV_D9:
+	case MPU6000_REV_D10:
+		debug("ID 0x%02x", _product);
+		return OK;
+	}
+
+	debug("unexpected ID 0x%02x", _product);
+	return -EIO;
+}
+
+ssize_t
+MPU60x0::read(struct file *filp, char *buffer, size_t buflen)
+{
+	int ret = 0;
+
+	/* buffer must be large enough */
+	if (buflen < sizeof(_accel_report))
+		return -ENOSPC;
+
+	/* if automatic measurement is not enabled */
+	if (_call_interval == 0)
+		measure();
+
+	/* copy out the latest reports */
+	memcpy(buffer, &_accel_report, sizeof(_accel_report));
+	ret = sizeof(_accel_report);
+
+	return ret;
+}
+
+int
+MPU60x0::self_test()
+{
+	if (_reads == 0) {
+		measure();
+	}
+
+	/* return 0 on success, 1 else */
+	return (_reads > 0) ? 0 : 1;
+}
+
+ssize_t
+MPU60x0::gyro_read(struct file *filp, char *buffer, size_t buflen)
+{
+	int ret = 0;
+
+	/* buffer must be large enough */
+	if (buflen < sizeof(_gyro_report))
+		return -ENOSPC;
+
+	/* if automatic measurement is not enabled */
+	if (_call_interval == 0)
+		measure();
+
+	/* copy out the latest report */
+	memcpy(buffer, &_gyro_report, sizeof(_gyro_report));
+	ret = sizeof(_gyro_report);
+
+	return ret;
+}
+
+int
+MPU60x0::ioctl(struct file *filp, int cmd, unsigned long arg)
+{
+	switch (cmd) {
+
+	case SENSORIOCSPOLLRATE: {
+			switch (arg) {
+
+				/* switching to manual polling */
+			case SENSOR_POLLRATE_MANUAL:
+				stop();
+				_call_interval = 0;
+				return OK;
+
+				/* external signalling not supported */
+			case SENSOR_POLLRATE_EXTERNAL:
+
+				/* zero would be bad */
+			case 0:
+				return -EINVAL;
+
+				/* set default/max polling rate */
+			case SENSOR_POLLRATE_MAX:
+			case SENSOR_POLLRATE_DEFAULT:
+				/* XXX 500Hz is just a wild guess */
+				return ioctl(filp, SENSORIOCSPOLLRATE, 500);
+
+				/* adjust to a legal polling interval in Hz */
+			default: {
+					/* do we need to start internal polling? */
+					bool want_start = (_call_interval == 0);
+
+					/* convert hz to hrt interval via microseconds */
+					unsigned ticks = 1000000 / arg;
+
+					/* check against maximum sane rate */
+					if (ticks < 1000)
+						return -EINVAL;
+
+					/* update interval for next measurement */
+					/* XXX this is a bit shady, but no other way to adjust... */
+					_call.period = _call_interval = ticks;
+
+					/* if we need to start the poll state machine, do it */
+					if (want_start)
+						start();
+
+					return OK;
+				}
+			}
+		}
+
+	case SENSORIOCGPOLLRATE:
+		if (_call_interval == 0)
+			return SENSOR_POLLRATE_MANUAL;
+
+		return 1000000 / _call_interval;
+
+	case SENSORIOCSQUEUEDEPTH:
+		/* XXX not implemented */
+		return -EINVAL;
+
+	case SENSORIOCGQUEUEDEPTH:
+		/* XXX not implemented */
+		return -EINVAL;
+
+	case SENSORIOCRESET:
+		write_reg(MPUREG_PWR_MGMT_1, BIT_H_RESET);
+		up_udelay(10000);
+		return OK;
+
+	case ACCELIOCSSAMPLERATE:
+	case ACCELIOCGSAMPLERATE:
+		/* XXX not implemented */
+		return -EINVAL;
+
+	case ACCELIOCSLOWPASS:
+	case ACCELIOCGLOWPASS:
+		/* XXX not implemented */
+		return -EINVAL;
+
+	case ACCELIOCSSCALE:
+		{
+			/* copy scale, but only if off by a few percent */
+			struct accel_scale *s = (struct accel_scale *) arg;
+			float sum = s->x_scale + s->y_scale + s->z_scale;
+			if (sum > 2.0f && sum < 4.0f) {
+				memcpy(&_accel_scale, s, sizeof(_accel_scale));
+				return OK;
+			} else {
+				return -EINVAL;
+			}
+		}
+
+	case ACCELIOCGSCALE:
+		/* copy scale out */
+		memcpy((struct accel_scale *) arg, &_accel_scale, sizeof(_accel_scale));
+		return OK;
+
+	case ACCELIOCSRANGE:
+	case ACCELIOCGRANGE:
+		/* XXX not implemented */
+		// XXX change these two values on set:
+		// _accel_range_scale = (9.81f / 4096.0f);
+		// _accel_range_rad_s = 8.0f * 9.81f;
+		return -EINVAL;
+
+	case ACCELIOCSELFTEST:
+		return self_test();
+
+	default:
+		/* give it to the superclass */
+		return I2C::ioctl(filp, cmd, arg);
+	}
+}
+
+int
+MPU60x0::gyro_ioctl(struct file *filp, int cmd, unsigned long arg)
+{
+	switch (cmd) {
+
+		/* these are shared with the accel side */
+	case SENSORIOCSPOLLRATE:
+	case SENSORIOCGPOLLRATE:
+	case SENSORIOCSQUEUEDEPTH:
+	case SENSORIOCGQUEUEDEPTH:
+	case SENSORIOCRESET:
+		return ioctl(filp, cmd, arg);
+
+	case GYROIOCSSAMPLERATE:
+	case GYROIOCGSAMPLERATE:
+		/* XXX not implemented */
+		return -EINVAL;
+
+	case GYROIOCSLOWPASS:
+	case GYROIOCGLOWPASS:
+		/* XXX not implemented */
+		return -EINVAL;
+
+	case GYROIOCSSCALE:
+		/* copy scale in */
+		memcpy(&_gyro_scale, (struct gyro_scale *) arg, sizeof(_gyro_scale));
+		return OK;
+
+	case GYROIOCGSCALE:
+		/* copy scale out */
+		memcpy((struct gyro_scale *) arg, &_gyro_scale, sizeof(_gyro_scale));
+		return OK;
+
+	case GYROIOCSRANGE:
+	case GYROIOCGRANGE:
+		/* XXX not implemented */
+		// XXX change these two values on set:
+		// _gyro_range_scale = xx
+		// _gyro_range_m_s2 = xx
+		return -EINVAL;
+
+	case GYROIOCSELFTEST:
+		return self_test();
+
+	default:
+		/* give it to the superclass */
+		return I2C::ioctl(filp, cmd, arg);
+	}
+}
+
+uint8_t
+MPU60x0::read_reg(uint8_t reg)
+{
+	uint8_t val;
+
+	transfer(&reg, 1, &val, 1);
+	return val;
+}
+
+#if 0
+uint16_t
+MPU60x0::read_reg16(unsigned reg)
+{
+	uint8_t cmd[3];
+
+	cmd[0] = reg | DIR_READ;
+
+	transfer(cmd, cmd, sizeof(cmd));
+
+	return (uint16_t)(cmd[1] << 8) | cmd[2];
+}
+#endif
+
+void
+MPU60x0::write_reg(uint8_t reg, uint8_t value)
+{
+	uint8_t cmd[] = { reg, value };
+
+	transfer(&cmd[0], 2, nullptr, 0);
+}
+
+void
+MPU60x0::modify_reg(uint8_t reg, uint8_t clearbits, uint8_t setbits)
+{
+	uint8_t	val;
+
+	val = read_reg(reg);
+	val &= ~clearbits;
+	val |= setbits;
+	write_reg(reg, val);
+}
+
+int
+MPU60x0::set_range(unsigned max_g)
+{
+#if 0
+	uint8_t rangebits;
+	float rangescale;
+
+	if (max_g > 16) {
+		return -ERANGE;
+
+	} else if (max_g > 8) {		/* 16G */
+		rangebits = OFFSET_LSB1_RANGE_16G;
+		rangescale = 1.98;
+
+	} else if (max_g > 4) {		/* 8G */
+		rangebits = OFFSET_LSB1_RANGE_8G;
+		rangescale = 0.99;
+
+	} else if (max_g > 3) {		/* 4G */
+		rangebits = OFFSET_LSB1_RANGE_4G;
+		rangescale = 0.5;
+
+	} else if (max_g > 2) {		/* 3G */
+		rangebits = OFFSET_LSB1_RANGE_3G;
+		rangescale = 0.38;
+
+	} else if (max_g > 1) {		/* 2G */
+		rangebits = OFFSET_LSB1_RANGE_2G;
+		rangescale = 0.25;
+
+	} else {			/* 1G */
+		rangebits = OFFSET_LSB1_RANGE_1G;
+		rangescale = 0.13;
+	}
+
+	/* adjust sensor configuration */
+	modify_reg(ADDR_OFFSET_LSB1, OFFSET_LSB1_RANGE_MASK, rangebits);
+	_range_scale = rangescale;
+#endif
+	return OK;
+}
+
+void
+MPU60x0::start()
+{
+	/* make sure we are stopped first */
+	stop();
+
+	/* start polling at the specified rate */
+	hrt_call_every(&_call, 1000, _call_interval, (hrt_callout)&MPU60x0::measure_trampoline, this);
+}
+
+void
+MPU60x0::stop()
+{
+	hrt_cancel(&_call);
+}
+
+void
+MPU60x0::measure_trampoline(void *arg)
+{
+	MPU60x0 *dev = (MPU60x0 *)arg;
+
+	/* make another measurement */
+	dev->measure();
+}
+
+void
+MPU60x0::measure()
+{
+	uint8_t		cmd;
+	int	ret = -EIO;
+
+#pragma pack(push, 1)
+	/* Report values from MPU60x0 */
+	struct MPUReport {
+		uint8_t		accel_x[2];
+		uint8_t		accel_y[2];
+		uint8_t		accel_z[2];
+		uint8_t		temp[2];
+		uint8_t		gyro_x[2];
+		uint8_t		gyro_y[2];
+		uint8_t		gyro_z[2];
+	} mpu_report;
+#pragma pack(pop)
+
+	struct Report {
+		int16_t		accel_x;
+		int16_t		accel_y;
+		int16_t		accel_z;
+		int16_t		temp;
+		int16_t		gyro_x;
+		int16_t		gyro_y;
+		int16_t		gyro_z;
+	} report;
+
+	/* start measuring */
+	perf_begin(_sample_perf);
+
+	/*
+	 * Fetch the full set of measurements from the MPU60x0 in one pass.
+	 */
+	cmd = MPUREG_ACCEL_XOUT_H;
+	ret = transfer(&cmd, 1, (uint8_t *)&mpu_report, sizeof(mpu_report));
+	if (ret != OK) {
+		debug("data/status read error %d. Data read : ");
+		uint8_t *ptr = (uint8_t *) &mpu_report; 
+		for (uint8_t i = 0; i < sizeof(mpu_report); i++) {
+			debug("%d ", *ptr);
+		}
+		return;
+	}
+
+	/* count measurement */
+	_reads++;
+
+	/*
+	 * Convert from big to little endian
+	 */
+
+	report.accel_x = int16_t_from_bytes(mpu_report.accel_x);
+	report.accel_y = int16_t_from_bytes(mpu_report.accel_y);
+	report.accel_z = int16_t_from_bytes(mpu_report.accel_z);
+
+	report.temp = int16_t_from_bytes(mpu_report.temp);
+
+	report.gyro_x = int16_t_from_bytes(mpu_report.gyro_x);
+	report.gyro_y = int16_t_from_bytes(mpu_report.gyro_y);
+	report.gyro_z = int16_t_from_bytes(mpu_report.gyro_z);
+
+	/*
+	 * Swap axes and negate y
+	 */
+	int16_t accel_xt = report.accel_y;
+	int16_t accel_yt = ((report.accel_x == -32768) ? 32767 : -report.accel_x);
+
+	int16_t gyro_xt = report.gyro_y;
+	int16_t gyro_yt = ((report.gyro_x == -32768) ? 32767 : -report.gyro_x);
+
+	/*
+	 * Apply the swap
+	 */
+	report.accel_x = accel_xt;
+	report.accel_y = accel_yt;
+	report.gyro_x = gyro_xt;
+	report.gyro_y = gyro_yt;
+
+	/*
+	 * Adjust and scale results to m/s^2.
+	 */
+	_gyro_report.timestamp = _accel_report.timestamp = hrt_absolute_time();
+
+
+	/*
+	 * 1) Scale raw value to SI units using scaling from datasheet.
+	 * 2) Subtract static offset (in SI units)
+	 * 3) Scale the statically calibrated values with a linear
+	 *    dynamically obtained factor
+	 *
+	 * Note: the static sensor offset is the number the sensor outputs
+	 * 	 at a nominally 'zero' input. Therefore the offset has to
+	 * 	 be subtracted.
+	 *
+	 *	 Example: A gyro outputs a value of 74 at zero angular rate
+	 *	 	  the offset is 74 from the origin and subtracting
+	 *		  74 from all measurements centers them around zero.
+	 */
+
+
+	/* NOTE: Axes have been swapped to match the board a few lines above. */
+
+	_accel_report.x_raw = report.accel_x;
+	_accel_report.y_raw = report.accel_y;
+	_accel_report.z_raw = report.accel_z;
+
+	_accel_report.x = ((report.accel_x * _accel_range_scale) - _accel_scale.x_offset) * _accel_scale.x_scale;
+	_accel_report.y = ((report.accel_y * _accel_range_scale) - _accel_scale.y_offset) * _accel_scale.y_scale;
+	_accel_report.z = ((report.accel_z * _accel_range_scale) - _accel_scale.z_offset) * _accel_scale.z_scale;
+	_accel_report.scaling = _accel_range_scale;
+	_accel_report.range_m_s2 = _accel_range_m_s2;
+
+	_accel_report.temperature_raw = report.temp;
+	_accel_report.temperature = (report.temp) / 361.0f + 35.0f;
+
+	_gyro_report.x_raw = report.gyro_x;
+	_gyro_report.y_raw = report.gyro_y;
+	_gyro_report.z_raw = report.gyro_z;
+
+	_gyro_report.x = ((report.gyro_x * _gyro_range_scale) - _gyro_scale.x_offset) * _gyro_scale.x_scale;
+	_gyro_report.y = ((report.gyro_y * _gyro_range_scale) - _gyro_scale.y_offset) * _gyro_scale.y_scale;
+	_gyro_report.z = ((report.gyro_z * _gyro_range_scale) - _gyro_scale.z_offset) * _gyro_scale.z_scale;
+	_gyro_report.scaling = _gyro_range_scale;
+	_gyro_report.range_rad_s = _gyro_range_rad_s;
+
+	_gyro_report.temperature_raw = report.temp;
+	_gyro_report.temperature = (report.temp) / 361.0f + 35.0f;
+
+	/* notify anyone waiting for data */
+	poll_notify(POLLIN);
+	_gyro->parent_poll_notify();
+
+	/* and publish for subscribers */
+	orb_publish(ORB_ID(sensor_accel), _accel_topic, &_accel_report);
+	if (_gyro_topic != -1) {
+		orb_publish(ORB_ID(sensor_gyro), _gyro_topic, &_gyro_report);
+	}
+
+	/* stop measuring */
+	perf_end(_sample_perf);
+}
+
+void
+MPU60x0::print_info()
+{
+	printf("reads:          %u\n", _reads);
+}
+
+MPU60x0_gyro::MPU60x0_gyro(MPU60x0 *parent) :
+	CDev("MPU60x0_gyro", GYRO_DEVICE_PATH),
+	_parent(parent)
+{
+}
+
+MPU60x0_gyro::~MPU60x0_gyro()
+{
+}
+
+void
+MPU60x0_gyro::parent_poll_notify()
+{
+	poll_notify(POLLIN);
+}
+
+ssize_t
+MPU60x0_gyro::read(struct file *filp, char *buffer, size_t buflen)
+{
+	return _parent->gyro_read(filp, buffer, buflen);
+}
+
+int
+MPU60x0_gyro::ioctl(struct file *filp, int cmd, unsigned long arg)
+{
+	return _parent->gyro_ioctl(filp, cmd, arg);
+}
+
+/**
+ * Local functions in support of the shell command.
+ */
+namespace mpu60x0
+{
+
+MPU60x0	*g_dev;
+
+void	start();
+void	test();
+void	reset();
+void	info();
+
+/**
+ * Start the driver.
+ */
+void
+start()
+{
+	int fd;
+	if (g_dev != nullptr)
+		errx(1, "already started");
+	
+	/* create the driver */
+	g_dev = new MPU60x0(MPU60x0_BUS);
+
+	if (g_dev == nullptr) {
+		errx(1, "MPU60x0 instanciation failed");
+		goto fail;
+	}
+
+	if (OK != g_dev->init()) {
+		errx(1, "MPU60x0 init  failed");
+		goto fail;
+	}
+
+	/* set the poll rate to default, starts automatic data collection */
+	fd = open(ACCEL_DEVICE_PATH, O_RDONLY);
+
+	if (fd < 0)
+		goto fail;
+
+	if (ioctl(fd, SENSORIOCSPOLLRATE, SENSOR_POLLRATE_DEFAULT) < 0) {
+		errx(1, "ioctl failed");
+		goto fail;
+	}
+
+	exit(0);
+fail:
+
+	if (g_dev != nullptr) {
+		delete g_dev;
+		g_dev = nullptr;
+	}
+
+	errx(1, "driver start failed");
+}
+
+/**
+ * Perform some basic functional tests on the driver;
+ * make sure we can collect data from the sensor in polled
+ * and automatic modes.
+ */
+void
+test()
+{
+	int fd = -1;
+	int fd_gyro = -1;
+	struct accel_report a_report;
+	struct gyro_report g_report;
+	ssize_t sz;
+
+	/* get the driver */
+	fd = open(ACCEL_DEVICE_PATH, O_RDONLY);
+
+	if (fd < 0)
+		err(1, "%s open failed (try 'mpu60x0 start' if the driver is not running)",
+		    ACCEL_DEVICE_PATH);
+
+	/* get the driver */
+	fd_gyro = open(GYRO_DEVICE_PATH, O_RDONLY);
+
+	if (fd_gyro < 0)
+		err(1, "%s open failed", GYRO_DEVICE_PATH);
+
+	/* reset to manual polling */
+	if (ioctl(fd, SENSORIOCSPOLLRATE, SENSOR_POLLRATE_MANUAL) < 0)
+		err(1, "reset to manual polling");
+
+	for (int i = 0; i < 10; i++) {
+		/* do a simple demand read */
+		sz = read(fd, &a_report, sizeof(a_report));
+
+		if (sz != sizeof(a_report))
+			err(1, "immediate acc read failed");
+
+		warnx("single read");
+		warnx("time:     %lld", a_report.timestamp);
+		warnx("acc  x:  \t%8.4f\tm/s^2", (double)a_report.x);
+		warnx("acc  y:  \t%8.4f\tm/s^2", (double)a_report.y);
+		warnx("acc  z:  \t%8.4f\tm/s^2", (double)a_report.z);
+		warnx("acc  x:  \t%d\traw 0x%0x", (short)a_report.x_raw, (unsigned short)a_report.x_raw);
+		warnx("acc  y:  \t%d\traw 0x%0x", (short)a_report.y_raw, (unsigned short)a_report.y_raw);
+		warnx("acc  z:  \t%d\traw 0x%0x", (short)a_report.z_raw, (unsigned short)a_report.z_raw);
+		warnx("acc range: %8.4f m/s^2 (%8.4f g)", (double)a_report.range_m_s2,
+				(double)(a_report.range_m_s2 / 9.81f));
+
+		/* do a simple demand read */
+		sz = read(fd_gyro, &g_report, sizeof(g_report));
+
+		if (sz != sizeof(g_report))
+			err(1, "immediate gyro read failed");
+
+		warnx("gyro x: \t% 9.5f\trad/s", (double)g_report.x);
+		warnx("gyro y: \t% 9.5f\trad/s", (double)g_report.y);
+		warnx("gyro z: \t% 9.5f\trad/s", (double)g_report.z);
+		warnx("gyro x: \t%d\traw", (int)g_report.x_raw);
+		warnx("gyro y: \t%d\traw", (int)g_report.y_raw);
+		warnx("gyro z: \t%d\traw", (int)g_report.z_raw);
+		warnx("gyro range: %8.4f rad/s (%d deg/s)", (double)g_report.range_rad_s,
+				(int)((g_report.range_rad_s / M_PI_F) * 180.0f + 0.5f));
+
+		warnx("temp:  \t%8.4f\tdeg celsius", (double)a_report.temperature);
+		warnx("temp:  \t%d\traw 0x%0x", (short)a_report.temperature_raw, (unsigned short)a_report.temperature_raw);
+	}
+
+	/* XXX add poll-rate tests here too */
+
+	reset();
+	errx(0, "PASS");
+}
+
+/**
+ * Reset the driver.
+ */
+void
+reset()
+{
+	int fd = open(ACCEL_DEVICE_PATH, O_RDONLY);
+
+	if (fd < 0)
+		err(1, "failed ");
+
+	if (ioctl(fd, SENSORIOCRESET, 0) < 0)
+		err(1, "driver reset failed");
+
+	if (ioctl(fd, SENSORIOCSPOLLRATE, SENSOR_POLLRATE_DEFAULT) < 0)
+		err(1, "driver poll restart failed");
+
+	exit(0);
+}
+
+/**
+ * Print a little info about the driver.
+ */
+void
+info()
+{
+	if (g_dev == nullptr)
+		errx(1, "driver not running");
+
+	printf("state @ %p\n", g_dev);
+	g_dev->print_info();
+
+	exit(0);
+}
+
+
+} // namespace
+
+int
+mpu60x0_main(int argc, char *argv[])
+{
+	/*
+	 * Start/load the driver.
+
+	 */
+	if (!strcmp(argv[1], "start"))
+		mpu60x0::start();
+	else
+	/*
+	 * Test the driver/device.
+	 */
+	if (!strcmp(argv[1], "test"))
+		mpu60x0::test();
+	else
+	/*
+	 * Reset the driver.
+	 */
+	if (!strcmp(argv[1], "reset"))
+		mpu60x0::reset();
+	else
+	/*
+	 * Print driver information.
+	 */
+	if (!strcmp(argv[1], "info"))
+		mpu60x0::info();
+	else
+		errx(1, "unrecognized command, try 'start', 'test', 'reset' or 'info'");
+}
diff --git a/src/drivers/navstik/fmu.cpp b/src/drivers/navstik/fmu.cpp
new file mode 100644
index 0000000..170acf7
--- /dev/null
+++ b/src/drivers/navstik/fmu.cpp
@@ -0,0 +1,965 @@
+/****************************************************************************
+ *
+ *   Copyright (C) 2013 Navstik Development Team. Based on PX4 port.
+ *   Copyright (C) 2012 PX4 Development Team. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name PX4 nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/**
+ * @file fmu.cpp
+ *
+ * Driver/configurator for the PX4 FMU multi-purpose port.
+ */
+
+#include <nuttx/config.h>
+
+#include <sys/types.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <semaphore.h>
+#include <string.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <errno.h>
+#include <stdio.h>
+#include <math.h>
+#include <unistd.h>
+
+#include <nuttx/arch.h>
+
+#include <drivers/device/device.h>
+#include <drivers/drv_pwm_output.h>
+#include <drivers/drv_gpio.h>
+#include <drivers/boards/navstik/navstik_internal.h>
+#include <drivers/drv_hrt.h>
+
+#include <systemlib/systemlib.h>
+#include <systemlib/err.h>
+#include <systemlib/mixer/mixer.h>
+#include <drivers/drv_mixer.h>
+#include <drivers/drv_rc_input.h>
+
+#include <uORB/topics/actuator_controls.h>
+#include <uORB/topics/actuator_controls_effective.h>
+#include <uORB/topics/actuator_outputs.h>
+
+#include <systemlib/err.h>
+#include <systemlib/ppm_decode.h>
+
+class NAVSTIK : public device::CDev
+{
+public:
+	enum Mode {
+		MODE_2PWM,
+		MODE_4PWM,
+		MODE_NONE
+	};
+	NAVSTIK();
+	~NAVSTIK();
+
+	virtual int	ioctl(file *filp, int cmd, unsigned long arg);
+
+	virtual int	init();
+
+	int		set_mode(Mode mode);
+	int		set_pwm_rate(unsigned rate);
+
+private:
+	static const unsigned _max_actuators = 4;
+
+	Mode		_mode;
+	int 		_update_rate;
+	int 		_current_update_rate;
+	int		_task;
+	int		_t_actuators;
+	int		_t_armed;
+	orb_advert_t	_t_outputs;
+	orb_advert_t	_t_actuators_effective;
+	unsigned	_num_outputs;
+	bool		_primary_pwm_device;
+
+	volatile bool	_task_should_exit;
+	bool		_armed;
+
+	MixerGroup	*_mixers;
+
+	actuator_controls_s _controls;
+
+	static void	task_main_trampoline(int argc, char *argv[]);
+	void		task_main() __attribute__((noreturn));
+
+	static int	control_callback(uintptr_t handle,
+					 uint8_t control_group,
+					 uint8_t control_index,
+					 float &input);
+
+	int		pwm_ioctl(file *filp, int cmd, unsigned long arg);
+
+	struct GPIOConfig {
+		uint32_t	input;
+		uint32_t	output;
+		uint32_t	alt;
+	};
+
+	static const GPIOConfig	_gpio_tab[];
+	static const unsigned	_ngpio;
+
+	void		gpio_reset(void);
+	void		gpio_set_function(uint32_t gpios, int function);
+	void		gpio_write(uint32_t gpios, int function);
+	uint32_t	gpio_read(void);
+	int		gpio_ioctl(file *filp, int cmd, unsigned long arg);
+
+};
+
+const NAVSTIK::GPIOConfig NAVSTIK::_gpio_tab[] = {
+/*
+	{GPIO_GPIO0_INPUT, GPIO_GPIO0_OUTPUT, 0},
+	{GPIO_GPIO1_INPUT, GPIO_GPIO1_OUTPUT, 0},
+	{GPIO_GPIO2_INPUT, GPIO_GPIO2_OUTPUT, GPIO_USART2_CTS_1},
+	{GPIO_GPIO3_INPUT, GPIO_GPIO3_OUTPUT, GPIO_USART2_RTS_1},
+	{GPIO_GPIO4_INPUT, GPIO_GPIO4_OUTPUT, GPIO_USART2_TX_1},
+	{GPIO_GPIO5_INPUT, GPIO_GPIO5_OUTPUT, GPIO_USART2_RX_1},
+	{GPIO_GPIO6_INPUT, GPIO_GPIO6_OUTPUT, GPIO_CAN2_TX_2},
+	{GPIO_GPIO7_INPUT, GPIO_GPIO7_OUTPUT, GPIO_CAN2_RX_2},
+*/
+};
+
+const unsigned NAVSTIK::_ngpio = sizeof(NAVSTIK::_gpio_tab) / sizeof(NAVSTIK::_gpio_tab[0]);
+
+namespace
+{
+
+NAVSTIK	*g_fmu;
+
+} // namespace
+
+NAVSTIK::NAVSTIK() :
+	CDev("fmuservo", NAVSTIK_DEVICE_PATH),
+	_mode(MODE_NONE),
+	_update_rate(50),
+	_task(-1),
+	_t_actuators(-1),
+	_t_armed(-1),
+	_t_outputs(0),
+	_t_actuators_effective(0),
+	_num_outputs(0),
+	_primary_pwm_device(false),
+	_task_should_exit(false),
+	_armed(false),
+	_mixers(nullptr)
+{
+	_debug_enabled = true;
+}
+
+NAVSTIK::~NAVSTIK()
+{
+	if (_task != -1) {
+		/* tell the task we want it to go away */
+		_task_should_exit = true;
+
+		unsigned i = 10;
+
+		do {
+			/* wait 50ms - it should wake every 100ms or so worst-case */
+			usleep(50000);
+
+			/* if we have given up, kill it */
+			if (--i == 0) {
+				task_delete(_task);
+				break;
+			}
+
+		} while (_task != -1);
+	}
+
+	/* clean up the alternate device node */
+	if (_primary_pwm_device)
+		unregister_driver(PWM_OUTPUT_DEVICE_PATH);
+
+	g_fmu = nullptr;
+}
+
+int
+NAVSTIK::init()
+{
+	int ret;
+
+	ASSERT(_task == -1);
+
+	/* do regular cdev init */
+	ret = CDev::init();
+
+	if (ret != OK)
+		return ret;
+
+	/* try to claim the generic PWM output device node as well - it's OK if we fail at this */
+	ret = register_driver(PWM_OUTPUT_DEVICE_PATH, &fops, 0666, (void *)this);
+
+	if (ret == OK) {
+		log("default PWM output device");
+		_primary_pwm_device = true;
+	}
+
+	/* reset GPIOs */
+	gpio_reset();
+
+	/* start the IO interface task */
+	_task = task_spawn_cmd("fmuservo",
+			   SCHED_DEFAULT,
+			   SCHED_PRIORITY_DEFAULT,
+			   2048,
+			   (main_t)&NAVSTIK::task_main_trampoline,
+			   nullptr);
+
+	if (_task < 0) {
+		debug("task start failed: %d", errno);
+		return -errno;
+	}
+
+	return OK;
+}
+
+void
+NAVSTIK::task_main_trampoline(int argc, char *argv[])
+{
+	g_fmu->task_main();
+}
+
+int
+NAVSTIK::set_mode(Mode mode)
+{
+	/*
+	 * Configure for PWM output.
+	 *
+	 * Note that regardless of the configured mode, the task is always
+	 * listening and mixing; the mode just selects which of the channels
+	 * are presented on the output pins.
+	 */
+	switch (mode) {
+	case MODE_2PWM:
+		debug("MODE_2PWM");
+		/* multi-port with flow control lines as PWM */
+		/* XXX magic numbers */
+		up_pwm_servo_init(0x3);
+		_update_rate = 50;	/* default output rate */
+		break;
+
+	case MODE_4PWM:
+		debug("MODE_4PWM");
+		/* multi-port as 4 PWM outs */
+		/* XXX magic numbers */
+		up_pwm_servo_init(0xf);
+		_update_rate = 50;	/* default output rate */
+		break;
+
+	case MODE_NONE:
+		debug("MODE_NONE");
+		/* disable servo outputs and set a very low update rate */
+		up_pwm_servo_deinit();
+		_update_rate = 10;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	_mode = mode;
+	return OK;
+}
+
+int
+NAVSTIK::set_pwm_rate(unsigned rate)
+{
+	if ((rate > 500) || (rate < 10))
+		return -EINVAL;
+
+	_update_rate = rate;
+	return OK;
+}
+
+void
+NAVSTIK::task_main()
+{
+	/*
+	 * Subscribe to the appropriate PWM output topic based on whether we are the
+	 * primary PWM output or not.
+	 */
+	_t_actuators = orb_subscribe(_primary_pwm_device ? ORB_ID_VEHICLE_ATTITUDE_CONTROLS :
+				     ORB_ID(actuator_controls_1));
+	/* force a reset of the update rate */
+	_current_update_rate = 0;
+
+	_t_armed = orb_subscribe(ORB_ID(actuator_armed));
+	orb_set_interval(_t_armed, 200);		/* 5Hz update rate */
+
+	/* advertise the mixed control outputs */
+	actuator_outputs_s outputs;
+	memset(&outputs, 0, sizeof(outputs));
+	/* advertise the mixed control outputs */
+	_t_outputs = orb_advertise(_primary_pwm_device ? ORB_ID_VEHICLE_CONTROLS : ORB_ID(actuator_outputs_1),
+				   &outputs);
+
+	/* advertise the effective control inputs */
+	actuator_controls_effective_s controls_effective;
+	memset(&controls_effective, 0, sizeof(controls_effective));
+	/* advertise the effective control inputs */
+	_t_actuators_effective = orb_advertise(_primary_pwm_device ? ORB_ID_VEHICLE_ATTITUDE_CONTROLS_EFFECTIVE : ORB_ID(actuator_controls_effective_1),
+				   &controls_effective);
+
+	pollfd fds[2];
+	fds[0].fd = _t_actuators;
+	fds[0].events = POLLIN;
+	fds[1].fd = _t_armed;
+	fds[1].events = POLLIN;
+
+	unsigned num_outputs = (_mode == MODE_2PWM) ? 2 : 4;
+
+	log("starting");
+
+	/* loop until killed */
+	while (!_task_should_exit) {
+
+		/* handle update rate changes */
+		if (_current_update_rate != _update_rate) {
+			int update_rate_in_ms = int(1000 / _update_rate);
+
+			/* reject faster than 500 Hz updates */
+			if (update_rate_in_ms < 2) {
+				update_rate_in_ms = 2;
+				_update_rate = 500;
+			}
+			/* reject slower than 50 Hz updates */
+			if (update_rate_in_ms > 20) {
+				update_rate_in_ms = 20;
+				_update_rate = 50;
+			}
+
+			orb_set_interval(_t_actuators, update_rate_in_ms);
+			up_pwm_servo_set_rate(_update_rate);
+			_current_update_rate = _update_rate;
+		}
+
+		/* sleep waiting for data, but no more than a second */
+		int ret = ::poll(&fds[0], 2, 1000);
+
+		/* this would be bad... */
+		if (ret < 0) {
+			log("poll error %d", errno);
+			usleep(1000000);
+			continue;
+		}
+
+		/* do we have a control update? */
+		if (fds[0].revents & POLLIN) {
+
+			/* get controls - must always do this to avoid spinning */
+			orb_copy(ORB_ID_VEHICLE_ATTITUDE_CONTROLS, _t_actuators, &_controls);
+
+			/* can we mix? */
+			if (_mixers != nullptr) {
+
+				/* do mixing */
+				outputs.noutputs = _mixers->mix(&outputs.output[0], num_outputs);
+				outputs.timestamp = hrt_absolute_time();
+
+				// XXX output actual limited values
+				memcpy(&controls_effective, &_controls, sizeof(controls_effective));
+
+				orb_publish(_primary_pwm_device ? ORB_ID_VEHICLE_ATTITUDE_CONTROLS_EFFECTIVE : ORB_ID(actuator_controls_effective_1), _t_actuators_effective, &controls_effective);
+
+				/* iterate actuators */
+				for (unsigned i = 0; i < num_outputs; i++) {
+
+					/* last resort: catch NaN, INF and out-of-band errors */
+					if (i < outputs.noutputs &&
+						isfinite(outputs.output[i]) &&
+						outputs.output[i] >= -1.0f &&
+						outputs.output[i] <= 1.0f) {
+						/* scale for PWM output 900 - 2100us */
+						outputs.output[i] = 1500 + (600 * outputs.output[i]);
+					} else {
+						/*
+						 * Value is NaN, INF or out of band - set to the minimum value.
+						 * This will be clearly visible on the servo status and will limit the risk of accidentally
+						 * spinning motors. It would be deadly in flight.
+						 */
+						outputs.output[i] = 900;
+					}
+
+					/* output to the servo */
+					up_pwm_servo_set(i, outputs.output[i]);
+				}
+
+				/* and publish for anyone that cares to see */
+				orb_publish(_primary_pwm_device ? ORB_ID_VEHICLE_CONTROLS : ORB_ID(actuator_outputs_1), _t_outputs, &outputs);
+			}
+		}
+
+		/* how about an arming update? */
+		if (fds[1].revents & POLLIN) {
+			actuator_armed_s aa;
+
+			/* get new value */
+			orb_copy(ORB_ID(actuator_armed), _t_armed, &aa);
+
+			/* update PWM servo armed status if armed and not locked down */
+			up_pwm_servo_arm(aa.armed && !aa.lockdown);
+		}
+	}
+
+	::close(_t_actuators);
+	::close(_t_actuators_effective);
+	::close(_t_armed);
+
+	/* make sure servos are off */
+	up_pwm_servo_deinit();
+
+	log("stopping");
+
+	/* note - someone else is responsible for restoring the GPIO config */
+
+	/* tell the dtor that we are exiting */
+	_task = -1;
+	_exit(0);
+}
+
+int
+NAVSTIK::control_callback(uintptr_t handle,
+			 uint8_t control_group,
+			 uint8_t control_index,
+			 float &input)
+{
+	const actuator_controls_s *controls = (actuator_controls_s *)handle;
+
+	input = controls->control[control_index];
+	return 0;
+}
+
+int
+NAVSTIK::ioctl(file *filp, int cmd, unsigned long arg)
+{
+	int ret;
+
+	// XXX disabled, confusing users
+	//debug("ioctl 0x%04x 0x%08x", cmd, arg);
+
+	/* try it as a GPIO ioctl first */
+	ret = gpio_ioctl(filp, cmd, arg);
+
+	if (ret != -ENOTTY)
+		return ret;
+
+	/* if we are in valid PWM mode, try it as a PWM ioctl as well */
+	switch (_mode) {
+	case MODE_2PWM:
+	case MODE_4PWM:
+		ret = pwm_ioctl(filp, cmd, arg);
+		break;
+
+	default:
+		debug("not in a PWM mode");
+		break;
+	}
+
+	/* if nobody wants it, let CDev have it */
+	if (ret == -ENOTTY)
+		ret = CDev::ioctl(filp, cmd, arg);
+
+	return ret;
+}
+
+int
+NAVSTIK::pwm_ioctl(file *filp, int cmd, unsigned long arg)
+{
+	int ret = OK;
+	int channel;
+
+	lock();
+
+	switch (cmd) {
+	case PWM_SERVO_ARM:
+		up_pwm_servo_arm(true);
+		break;
+
+	case PWM_SERVO_DISARM:
+		up_pwm_servo_arm(false);
+		break;
+
+	case PWM_SERVO_SET_UPDATE_RATE:
+		set_pwm_rate(arg);
+		break;
+
+	case PWM_SERVO_SET(2):
+	case PWM_SERVO_SET(3):
+		if (_mode != MODE_4PWM) {
+			ret = -EINVAL;
+			break;
+		}
+
+		/* FALLTHROUGH */
+	case PWM_SERVO_SET(0):
+	case PWM_SERVO_SET(1):
+		if (arg < 2100) {
+			channel = cmd - PWM_SERVO_SET(0);
+			up_pwm_servo_set(channel, arg);
+
+		} else {
+			ret = -EINVAL;
+		}
+
+		break;
+
+	case PWM_SERVO_GET(2):
+	case PWM_SERVO_GET(3):
+		if (_mode != MODE_4PWM) {
+			ret = -EINVAL;
+			break;
+		}
+
+		/* FALLTHROUGH */
+	case PWM_SERVO_GET(0):
+	case PWM_SERVO_GET(1): {
+			channel = cmd - PWM_SERVO_GET(0);
+			*(servo_position_t *)arg = up_pwm_servo_get(channel);
+			break;
+		}
+
+	case MIXERIOCGETOUTPUTCOUNT:
+		if (_mode == MODE_4PWM) {
+			*(unsigned *)arg = 4;
+
+		} else {
+			*(unsigned *)arg = 2;
+		}
+
+		break;
+
+	case MIXERIOCRESET:
+		if (_mixers != nullptr) {
+			delete _mixers;
+			_mixers = nullptr;
+		}
+
+		break;
+
+	case MIXERIOCADDSIMPLE: {
+			mixer_simple_s *mixinfo = (mixer_simple_s *)arg;
+
+			SimpleMixer *mixer = new SimpleMixer(control_callback,
+							     (uintptr_t)&_controls, mixinfo);
+
+			if (mixer->check()) {
+				delete mixer;
+				ret = -EINVAL;
+
+			} else {
+				if (_mixers == nullptr)
+					_mixers = new MixerGroup(control_callback,
+								 (uintptr_t)&_controls);
+
+				_mixers->add_mixer(mixer);
+			}
+
+			break;
+		}
+
+	case MIXERIOCLOADBUF: {
+			const char *buf = (const char *)arg;
+			unsigned buflen = strnlen(buf, 1024);
+
+			if (_mixers == nullptr)
+				_mixers = new MixerGroup(control_callback, (uintptr_t)&_controls);
+
+			if (_mixers == nullptr) {
+				ret = -ENOMEM;
+
+			} else {
+
+				ret = _mixers->load_from_buf(buf, buflen);
+
+				if (ret != 0) {
+					debug("mixer load failed with %d", ret);
+					delete _mixers;
+					_mixers = nullptr;
+					ret = -EINVAL;
+				}
+			}
+			break;
+		}
+
+	default:
+		ret = -ENOTTY;
+		break;
+	}
+
+	unlock();
+
+	return ret;
+}
+
+void
+NAVSTIK::gpio_reset(void)
+{
+	/*
+	 * Setup default GPIO config - all pins as GPIOs, GPIO driver chip
+	 * to input mode.
+	 */
+	for (unsigned i = 0; i < _ngpio; i++)
+		stm32_configgpio(_gpio_tab[i].input);
+}
+
+void
+NAVSTIK::gpio_set_function(uint32_t gpios, int function)
+{
+	/* configure selected GPIOs as required */
+	for (unsigned i = 0; i < _ngpio; i++) {
+		if (gpios & (1 << i)) {
+			switch (function) {
+			case GPIO_SET_INPUT:
+				stm32_configgpio(_gpio_tab[i].input);
+				break;
+
+			case GPIO_SET_OUTPUT:
+				stm32_configgpio(_gpio_tab[i].output);
+				break;
+
+			case GPIO_SET_ALT_1:
+				if (_gpio_tab[i].alt != 0)
+					stm32_configgpio(_gpio_tab[i].alt);
+
+				break;
+			}
+		}
+	}
+}
+
+void
+NAVSTIK::gpio_write(uint32_t gpios, int function)
+{
+	int value = (function == GPIO_SET) ? 1 : 0;
+
+	for (unsigned i = 0; i < _ngpio; i++)
+		if (gpios & (1 << i))
+			stm32_gpiowrite(_gpio_tab[i].output, value);
+}
+
+uint32_t
+NAVSTIK::gpio_read(void)
+{
+	uint32_t bits = 0;
+
+	for (unsigned i = 0; i < _ngpio; i++)
+		if (stm32_gpioread(_gpio_tab[i].input))
+			bits |= (1 << i);
+
+	return bits;
+}
+
+int
+NAVSTIK::gpio_ioctl(struct file *filp, int cmd, unsigned long arg)
+{
+	int	ret = OK;
+
+	lock();
+
+	switch (cmd) {
+
+	case GPIO_RESET:
+		gpio_reset();
+		break;
+
+	case GPIO_SET_OUTPUT:
+	case GPIO_SET_INPUT:
+	case GPIO_SET_ALT_1:
+		gpio_set_function(arg, cmd);
+		break;
+
+	case GPIO_SET_ALT_2:
+	case GPIO_SET_ALT_3:
+	case GPIO_SET_ALT_4:
+		ret = -EINVAL;
+		break;
+
+	case GPIO_SET:
+	case GPIO_CLEAR:
+		gpio_write(arg, cmd);
+		break;
+
+	case GPIO_GET:
+		*(uint32_t *)arg = gpio_read();
+		break;
+
+	default:
+		ret = -ENOTTY;
+	}
+
+	unlock();
+
+	return ret;
+}
+
+namespace
+{
+
+enum PortMode {
+	PORT_MODE_UNSET = 0,
+	PORT_FULL_GPIO,
+	PORT_FULL_SERIAL,
+	PORT_FULL_PWM,
+	PORT_GPIO_AND_SERIAL,
+	PORT_PWM_AND_SERIAL,
+	PORT_PWM_AND_GPIO,
+};
+
+PortMode g_port_mode;
+
+int
+fmu_new_mode(PortMode new_mode, int update_rate)
+{
+	uint32_t gpio_bits;
+	NAVSTIK::Mode servo_mode;
+
+	/* reset to all-inputs */
+	g_fmu->ioctl(0, GPIO_RESET, 0);
+
+	gpio_bits = 0;
+	servo_mode = NAVSTIK::MODE_NONE;
+
+	switch (new_mode) {
+	case PORT_FULL_GPIO:
+	case PORT_MODE_UNSET:
+		/* nothing more to do here */
+		break;
+
+	case PORT_FULL_SERIAL:
+		/* set all multi-GPIOs to serial mode */
+		gpio_bits = GPIO_MULTI_1 | GPIO_MULTI_2 | GPIO_MULTI_3 | GPIO_MULTI_4;
+		break;
+
+	case PORT_FULL_PWM:
+		/* select 4-pin PWM mode */
+		servo_mode = NAVSTIK::MODE_4PWM;
+		break;
+
+	case PORT_GPIO_AND_SERIAL:
+		/* set RX/TX multi-GPIOs to serial mode */
+		gpio_bits = GPIO_MULTI_3 | GPIO_MULTI_4;
+		break;
+
+	case PORT_PWM_AND_SERIAL:
+		/* select 2-pin PWM mode */
+		servo_mode = NAVSTIK::MODE_2PWM;
+		/* set RX/TX multi-GPIOs to serial mode */
+		gpio_bits = GPIO_MULTI_3 | GPIO_MULTI_4;
+		break;
+
+	case PORT_PWM_AND_GPIO:
+		/* select 2-pin PWM mode */
+		servo_mode = NAVSTIK::MODE_2PWM;
+		break;
+	}
+
+	/* adjust GPIO config for serial mode(s) */
+	if (gpio_bits != 0)
+		g_fmu->ioctl(0, GPIO_SET_ALT_1, gpio_bits);
+
+	/* (re)set the PWM output mode */
+	g_fmu->set_mode(servo_mode);
+
+	if ((servo_mode != NAVSTIK::MODE_NONE) && (update_rate != 0))
+		g_fmu->set_pwm_rate(update_rate);
+
+	return OK;
+}
+
+int
+fmu_start(void)
+{
+	int ret = OK;
+
+	if (g_fmu == nullptr) {
+
+		g_fmu = new NAVSTIK;
+
+		if (g_fmu == nullptr) {
+			ret = -ENOMEM;
+
+		} else {
+			ret = g_fmu->init();
+
+			if (ret != OK) {
+				delete g_fmu;
+				g_fmu = nullptr;
+			}
+		}
+	}
+
+	return ret;
+}
+
+void
+test(void)
+{
+	int	fd;
+
+	fd = open(PWM_OUTPUT_DEVICE_PATH, 0);
+
+	if (fd < 0)
+		errx(1, "open fail");
+
+	if (ioctl(fd, PWM_SERVO_ARM, 0) < 0)       err(1, "servo arm failed");
+
+	if (ioctl(fd, PWM_SERVO_SET(0), 1000) < 0) err(1, "servo 1 set failed");
+
+	if (ioctl(fd, PWM_SERVO_SET(1), 1200) < 0) err(1, "servo 2 set failed");
+
+	if (ioctl(fd, PWM_SERVO_SET(2), 1400) < 0) err(1, "servo 3 set failed");
+
+	if (ioctl(fd, PWM_SERVO_SET(3), 1600) < 0) err(1, "servo 4 set failed");
+
+	close(fd);
+
+	exit(0);
+}
+
+void
+fake(int argc, char *argv[])
+{
+	if (argc < 5)
+		errx(1, "fmu fake <roll> <pitch> <yaw> <thrust> (values -100 .. 100)");
+
+	actuator_controls_s ac;
+
+	ac.control[0] = strtol(argv[1], 0, 0) / 100.0f;
+
+	ac.control[1] = strtol(argv[2], 0, 0) / 100.0f;
+
+	ac.control[2] = strtol(argv[3], 0, 0) / 100.0f;
+
+	ac.control[3] = strtol(argv[4], 0, 0) / 100.0f;
+
+	orb_advert_t handle = orb_advertise(ORB_ID_VEHICLE_ATTITUDE_CONTROLS, &ac);
+
+	if (handle < 0)
+		errx(1, "advertise failed");
+
+	actuator_armed_s aa;
+
+	aa.armed = true;
+	aa.lockdown = false;
+
+	handle = orb_advertise(ORB_ID(actuator_armed), &aa);
+
+	if (handle < 0)
+		errx(1, "advertise failed 2");
+
+	exit(0);
+}
+
+} // namespace
+
+extern "C" __EXPORT int fmu_main(int argc, char *argv[]);
+
+int
+fmu_main(int argc, char *argv[])
+{
+	PortMode new_mode = PORT_MODE_UNSET;
+	int pwm_update_rate_in_hz = 0;
+
+	if (!strcmp(argv[1], "test"))
+		test();
+
+	if (!strcmp(argv[1], "fake"))
+		fake(argc - 1, argv + 1);
+
+	if (fmu_start() != OK)
+		errx(1, "failed to start the FMU driver");
+
+	/*
+	 * Mode switches.
+	 *
+	 * XXX use getopt?
+	 */
+	for (int i = 1; i < argc; i++) {   /* argv[0] is "fmu" */
+		if (!strcmp(argv[i], "mode_gpio")) {
+			new_mode = PORT_FULL_GPIO;
+
+		} else if (!strcmp(argv[i], "mode_serial")) {
+			new_mode = PORT_FULL_SERIAL;
+
+		} else if (!strcmp(argv[i], "mode_pwm")) {
+			new_mode = PORT_FULL_PWM;
+
+		} else if (!strcmp(argv[i], "mode_gpio_serial")) {
+			new_mode = PORT_GPIO_AND_SERIAL;
+
+		} else if (!strcmp(argv[i], "mode_pwm_serial")) {
+			new_mode = PORT_PWM_AND_SERIAL;
+
+		} else if (!strcmp(argv[i], "mode_pwm_gpio")) {
+			new_mode = PORT_PWM_AND_GPIO;
+		}
+
+		/* look for the optional pwm update rate for the supported modes */
+		if (strcmp(argv[i], "-u") == 0 || strcmp(argv[i], "--update-rate") == 0) {
+			if (new_mode == PORT_FULL_PWM || new_mode == PORT_PWM_AND_GPIO) {
+				if (argc > i + 1) {
+					pwm_update_rate_in_hz = atoi(argv[i + 1]);
+
+				} else {
+					errx(1, "missing argument for pwm update rate (-u)");
+					return 1;
+				}
+
+			} else {
+				errx(1, "pwm update rate currently only supported for mode_pwm, mode_pwm_gpio");
+			}
+		}
+	}
+
+	/* was a new mode set? */
+	if (new_mode != PORT_MODE_UNSET) {
+
+		/* yes but it's the same mode */
+		if (new_mode == g_port_mode)
+			return OK;
+
+		/* switch modes */
+		return fmu_new_mode(new_mode, pwm_update_rate_in_hz);
+	}
+
+	/* test, etc. here */
+
+	fprintf(stderr, "FMU: unrecognised command, try:\n");
+	fprintf(stderr, "  mode_gpio, mode_serial, mode_pwm [-u pwm_update_rate_in_hz], mode_gpio_serial, mode_pwm_serial, mode_pwm_gpio\n");
+	exit(1);
+}
diff --git a/src/drivers/navstik/module.mk b/src/drivers/navstik/module.mk
new file mode 100644
index 0000000..5d692f2
--- /dev/null
+++ b/src/drivers/navstik/module.mk
@@ -0,0 +1,7 @@
+#
+# Interface driver for the Navstik board
+#
+
+MODULE_COMMAND	 = fmu
+SRCS		 = fmu.cpp
+
diff --git a/src/drivers/stm32/adc/adc.cpp b/src/drivers/stm32/adc/adc.cpp
index 1020eb9..e3d3c8e 100644
--- a/src/drivers/stm32/adc/adc.cpp
+++ b/src/drivers/stm32/adc/adc.cpp
@@ -367,7 +367,8 @@ adc_main(int argc, char *argv[])
 {
 	if (g_adc == nullptr) {
 		/* XXX this hardcodes the default channel set for PX4FMU - should be configurable */
-		g_adc = new ADC((1 << 10) | (1 << 11) | (1 << 12) | (1 << 13));
+//		g_adc = new ADC((1 << 10) | (1 << 11) | (1 << 12) | (1 << 13));
+		g_adc = new ADC((1 << 1) | (1 << 11));
 
 		if (g_adc == nullptr)
 			errx(1, "couldn't allocate the ADC driver");
diff --git a/src/drivers/stm32/drv_hrt.c b/src/drivers/stm32/drv_hrt.c
index 7ef3db9..b2b496b 100644
--- a/src/drivers/stm32/drv_hrt.c
+++ b/src/drivers/stm32/drv_hrt.c
@@ -85,7 +85,7 @@
 #elif HRT_TIMER == 2
 # define HRT_TIMER_BASE		STM32_TIM2_BASE
 # define HRT_TIMER_POWER_REG	STM32_RCC_APB1ENR
-# define HRT_TIMER_POWER_BIT	RCC_APB2ENR_TIM2EN
+# define HRT_TIMER_POWER_BIT	RCC_APB1ENR_TIM2EN
 # define HRT_TIMER_VECTOR	STM32_IRQ_TIM2
 # define HRT_TIMER_CLOCK	STM32_APB1_TIM2_CLKIN
 # if CONFIG_STM32_TIM2
@@ -94,7 +94,7 @@
 #elif HRT_TIMER == 3
 # define HRT_TIMER_BASE		STM32_TIM3_BASE
 # define HRT_TIMER_POWER_REG	STM32_RCC_APB1ENR
-# define HRT_TIMER_POWER_BIT	RCC_APB2ENR_TIM3EN
+# define HRT_TIMER_POWER_BIT	RCC_APB1ENR_TIM3EN
 # define HRT_TIMER_VECTOR	STM32_IRQ_TIM3
 # define HRT_TIMER_CLOCK	STM32_APB1_TIM3_CLKIN
 # if CONFIG_STM32_TIM3
@@ -103,7 +103,7 @@
 #elif HRT_TIMER == 4
 # define HRT_TIMER_BASE		STM32_TIM4_BASE
 # define HRT_TIMER_POWER_REG	STM32_RCC_APB1ENR
-# define HRT_TIMER_POWER_BIT	RCC_APB2ENR_TIM4EN
+# define HRT_TIMER_POWER_BIT	RCC_APB1ENR_TIM4EN
 # define HRT_TIMER_VECTOR	STM32_IRQ_TIM4
 # define HRT_TIMER_CLOCK	STM32_APB1_TIM4_CLKIN
 # if CONFIG_STM32_TIM4
@@ -112,7 +112,7 @@
 #elif HRT_TIMER == 5
 # define HRT_TIMER_BASE		STM32_TIM5_BASE
 # define HRT_TIMER_POWER_REG	STM32_RCC_APB1ENR
-# define HRT_TIMER_POWER_BIT	RCC_APB2ENR_TIM5EN
+# define HRT_TIMER_POWER_BIT	RCC_APB1ENR_TIM5EN
 # define HRT_TIMER_VECTOR	STM32_IRQ_TIM5
 # define HRT_TIMER_CLOCK	STM32_APB1_TIM5_CLKIN
 # if CONFIG_STM32_TIM5
@@ -129,7 +129,7 @@
 # endif
 #elif HRT_TIMER == 9
 # define HRT_TIMER_BASE		STM32_TIM9_BASE
-# define HRT_TIMER_POWER_REG	STM32_RCC_APB1ENR
+# define HRT_TIMER_POWER_REG	STM32_RCC_APB2ENR
 # define HRT_TIMER_POWER_BIT	RCC_APB2ENR_TIM9EN
 # define HRT_TIMER_VECTOR	STM32_IRQ_TIM1BRK
 # define HRT_TIMER_CLOCK	STM32_APB1_TIM9_CLKIN
@@ -138,7 +138,7 @@
 # endif
 #elif HRT_TIMER == 10
 # define HRT_TIMER_BASE		STM32_TIM10_BASE
-# define HRT_TIMER_POWER_REG	STM32_RCC_APB1ENR
+# define HRT_TIMER_POWER_REG	STM32_RCC_APB2ENR
 # define HRT_TIMER_POWER_BIT	RCC_APB2ENR_TIM10EN
 # define HRT_TIMER_VECTOR	STM32_IRQ_TIM1UP
 # define HRT_TIMER_CLOCK	STM32_APB1_TIM10_CLKIN
@@ -147,7 +147,7 @@
 # endif
 #elif HRT_TIMER == 11
 # define HRT_TIMER_BASE		STM32_TIM11_BASE
-# define HRT_TIMER_POWER_REG	STM32_RCC_APB1ENR
+# define HRT_TIMER_POWER_REG	STM32_RCC_APB2ENR
 # define HRT_TIMER_POWER_BIT	RCC_APB2ENR_TIM11EN
 # define HRT_TIMER_VECTOR	STM32_IRQ_TIM1TRGCOM
 # define HRT_TIMER_CLOCK	STM32_APB1_TIM11_CLKIN
diff --git a/src/drivers/stm32/drv_pwm_servo.h b/src/drivers/stm32/drv_pwm_servo.h
index 5dd4cf7..777c50a 100644
--- a/src/drivers/stm32/drv_pwm_servo.h
+++ b/src/drivers/stm32/drv_pwm_servo.h
@@ -43,7 +43,7 @@
 
 /* configuration limits */
 #define PWM_SERVO_MAX_TIMERS	4
-#define PWM_SERVO_MAX_CHANNELS	8
+#define PWM_SERVO_MAX_CHANNELS	6
 
 /* array of timers dedicated to PWM servo use */
 struct pwm_servo_timer {
diff --git a/src/modules/sensors/sensors.cpp b/src/modules/sensors/sensors.cpp
index 5722d2f..be51375 100644
--- a/src/modules/sensors/sensors.cpp
+++ b/src/modules/sensors/sensors.cpp
@@ -1176,8 +1176,10 @@ Sensors::ppm_poll()
 		if (channel_limit > _rc_max_chan_count)
 			channel_limit = _rc_max_chan_count;
 
+#if CONFIG_HRT_PPM
 		/* we are accepting this message */
 		_ppm_last_valid = rc_input.timestamp;
+#endif
 
 		/* Read out values from raw message */
 		for (unsigned int i = 0; i < channel_limit; i++) {
diff --git a/src/systemcmds/eeprom/eeprom.c b/src/systemcmds/eeprom/eeprom.c
index 49da513..7e8c189 100644
--- a/src/systemcmds/eeprom/eeprom.c
+++ b/src/systemcmds/eeprom/eeprom.c
@@ -61,8 +61,15 @@
 #include "systemlib/param/param.h"
 #include "systemlib/err.h"
 
-#ifndef PX4_I2C_BUS_ONBOARD
-#  error PX4_I2C_BUS_ONBOARD not defined, cannot locate onboard EEPROM
+#ifdef CONFIG_ARCH_BOARD_PX4FMU_V1 || CONFIG_ARCH_BOARD_PX4IO
+#define EEPROM_BUS			PX4_I2C_BUS_ONBOARD
+#endif
+
+#ifdef CONFIG_ARCH_BOARD_NAVSTIK
+#ifndef NAVSTIK_I2C_BUS_SENSORS
+#  error NAVSTIK_I2C_BUS_SENSORS not defined, no device interface
+#endif
+#define EEPROM_BUS			NAVSTIK_I2C_BUS_SENSORS
 #endif
 
 __EXPORT int eeprom_main(int argc, char *argv[]);
@@ -115,7 +122,7 @@ static void
 eeprom_attach(void)
 {
 	/* find the right I2C */
-	struct i2c_dev_s *i2c = up_i2cinitialize(PX4_I2C_BUS_ONBOARD);
+	struct i2c_dev_s *i2c = up_i2cinitialize(EEPROM_BUS);
 	/* this resets the I2C bus, set correct bus speed again */
 	I2C_SETFREQUENCY(i2c, 400000);
 
diff --git a/src/systemcmds/i2c/i2c.c b/src/systemcmds/i2c/i2c.c
index 4da2380..c3b2e57 100644
--- a/src/systemcmds/i2c/i2c.c
+++ b/src/systemcmds/i2c/i2c.c
@@ -57,13 +57,30 @@
 #include "systemlib/systemlib.h"
 #include "systemlib/err.h"
 
+#ifdef CONFIG_ARCH_BOARD_PX4FMU_V1 || CONFIG_ARCH_BOARD_PX4IO
+
 #ifndef PX4_I2C_BUS_ONBOARD
 #  error PX4_I2C_BUS_ONBOARD not defined, no device interface
 #endif
+
+#define I2C_BUS		PX4_I2C_BUS_ONBOARD
+
 #ifndef PX4_I2C_OBDEV_PX4IO
 #  error PX4_I2C_OBDEV_PX4IO not defined
 #endif
 
+#endif
+
+#ifdef CONFIG_ARCH_BOARD_NAVSTIK
+
+#ifndef NAVSTIK_I2C_BUS_SENSORS
+#  error NAVSTIK_I2C_BUS_SENSORS not defined, no device interface
+#endif
+
+#define I2C_BUS		NAVSTIK_I2C_BUS_SENSORS
+
+#endif
+
 __EXPORT int i2c_main(int argc, char *argv[]);
 
 static int transfer(uint8_t address, uint8_t *send, unsigned send_len, uint8_t *recv, unsigned recv_len);
@@ -73,13 +90,14 @@ static struct i2c_dev_s *i2c;
 int i2c_main(int argc, char *argv[])
 {
 	/* find the right I2C */
-	i2c = up_i2cinitialize(PX4_I2C_BUS_ONBOARD);
+	i2c = up_i2cinitialize(I2C_BUS);
 
 	if (i2c == NULL)
 		errx(1, "failed to locate I2C bus");
 
 	usleep(100000);
 
+#ifdef PX4_I2C_OBDEV_PX4IO
 	uint8_t buf[] = { 0, 4};
 	int ret = transfer(PX4_I2C_OBDEV_PX4IO, buf, sizeof(buf), NULL, 0);
 
@@ -92,6 +110,7 @@ int i2c_main(int argc, char *argv[])
 		errx(1, "recive failed - %d", ret);
 
 	errx(0, "got 0x%08x", val);
+#endif
 }
 
 static int
